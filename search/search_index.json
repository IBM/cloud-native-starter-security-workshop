{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Workshop: Get started with security for your Java Microservices application \u00b6 As a developer you should ask yourself: \"How can I make my application (more) secure?\" In this workshop you will learn how to get started with Application Security from two perspectives: Platform security Authentication and Authorization implementation We will show you with an example application: How to secure external access to a Kubernetes cluster with TLS How to secure communication between Microservices with Istio and mTLS How to implement authorization and authentication with the Open Source Identity and Access Management system Keycloak and JSON Web Tokens (JWT) The exercises are based on an example application based on our Open Source Github project Cloud Native Starter , build with Quarkus and Microprofile The following screenshot shows the web application, you have to logon to see the list of articles. Architecture \u00b6 The following diagram shows the architecture of the sample application. There is a Web-App service that serves the Javascript/Vue.js code to the browser. The Web-App code running in the browser invokes a REST API of the Web-API microservice. The Web-API microservice in turn invokes a REST API of the Articles microservice. To see the results in the web application, users need to be authenticated and they need to have the role user . Estimated time and level \u00b6 Time Level one hour beginners Objectives \u00b6 After you complete this workshop, you'll understand the following application security related topics: Application security provided by the platform TLS / HTTPS mTLS Application security with Keycloak and Quarkus Authentication with Keycloak on the Web Fronted Authorization in Quarkus for specific Microservices in the backend The scope of this workshop is not to explain every aspect of application security. About this workshop \u00b6 Agenda \u00b6 These are the sections of this workshop, go through all of them in sequence, start with 1. Setup the IBM Cloud Environment : Setup the IBM Cloud Environment Setup the IBM Cloud application environment Platform security with mTLS Application security with Keycloak and Quarkus Compatibility \u00b6 The workshop with his two major parts, has been tested on the following platforms and local installations: Platform security IBM Cloud Kubernetes Service: Kubernetes Version 1.17, Istio Version 1.5 on IBM Cloud (pre-provisioned for the workshop or a paid cluster) IBM Cloud Shell: Version 1.0.2 Authorization and authentication implementation git 2.24.1 yarn 1.22.4 Node.js v14.6.0 Apache Maven 3.6.3 Docker 3.0.4 Java 9 Technology Used \u00b6 Microservices architecture KEYCLOAK Jakarta EE MicroProfile Quarkus Ingress Istio Vue.js NGINX Kubernetes git 2.24.1 or higher yarn 1.22.4 or higher Node.js v14.6.0 or higher Apache Maven 3.6.3 Credits \u00b6 Niklas Heidloff Harald Uebele Thomas S\u00fcdbr\u00f6cker Additional resources \u00b6 Here are some blogs that describe how this project has been implemented- The presentation that goes with this workshop is available here .","title":"About the workshop"},{"location":"#workshop-get-started-with-security-for-your-java-microservices-application","text":"As a developer you should ask yourself: \"How can I make my application (more) secure?\" In this workshop you will learn how to get started with Application Security from two perspectives: Platform security Authentication and Authorization implementation We will show you with an example application: How to secure external access to a Kubernetes cluster with TLS How to secure communication between Microservices with Istio and mTLS How to implement authorization and authentication with the Open Source Identity and Access Management system Keycloak and JSON Web Tokens (JWT) The exercises are based on an example application based on our Open Source Github project Cloud Native Starter , build with Quarkus and Microprofile The following screenshot shows the web application, you have to logon to see the list of articles.","title":"Workshop: Get started with security for your Java Microservices application"},{"location":"#architecture","text":"The following diagram shows the architecture of the sample application. There is a Web-App service that serves the Javascript/Vue.js code to the browser. The Web-App code running in the browser invokes a REST API of the Web-API microservice. The Web-API microservice in turn invokes a REST API of the Articles microservice. To see the results in the web application, users need to be authenticated and they need to have the role user .","title":"Architecture"},{"location":"#estimated-time-and-level","text":"Time Level one hour beginners","title":"Estimated time and level"},{"location":"#objectives","text":"After you complete this workshop, you'll understand the following application security related topics: Application security provided by the platform TLS / HTTPS mTLS Application security with Keycloak and Quarkus Authentication with Keycloak on the Web Fronted Authorization in Quarkus for specific Microservices in the backend The scope of this workshop is not to explain every aspect of application security.","title":"Objectives"},{"location":"#about-this-workshop","text":"","title":"About this workshop"},{"location":"#agenda","text":"These are the sections of this workshop, go through all of them in sequence, start with 1. Setup the IBM Cloud Environment : Setup the IBM Cloud Environment Setup the IBM Cloud application environment Platform security with mTLS Application security with Keycloak and Quarkus","title":"Agenda"},{"location":"#compatibility","text":"The workshop with his two major parts, has been tested on the following platforms and local installations: Platform security IBM Cloud Kubernetes Service: Kubernetes Version 1.17, Istio Version 1.5 on IBM Cloud (pre-provisioned for the workshop or a paid cluster) IBM Cloud Shell: Version 1.0.2 Authorization and authentication implementation git 2.24.1 yarn 1.22.4 Node.js v14.6.0 Apache Maven 3.6.3 Docker 3.0.4 Java 9","title":"Compatibility"},{"location":"#technology-used","text":"Microservices architecture KEYCLOAK Jakarta EE MicroProfile Quarkus Ingress Istio Vue.js NGINX Kubernetes git 2.24.1 or higher yarn 1.22.4 or higher Node.js v14.6.0 or higher Apache Maven 3.6.3","title":"Technology Used"},{"location":"#credits","text":"Niklas Heidloff Harald Uebele Thomas S\u00fcdbr\u00f6cker","title":"Credits"},{"location":"#additional-resources","text":"Here are some blogs that describe how this project has been implemented- The presentation that goes with this workshop is available here .","title":"Additional resources"},{"location":"BLOGS/","text":"Blogs \u00b6 Here are some blogs that describe how this project has been implemented: Setting up Keycloak in OpenShift Security in Quarkus Applications via Keycloak Securing Vue.js Applications with Keycloak","title":"Blog posts related to security"},{"location":"BLOGS/#blogs","text":"Here are some blogs that describe how this project has been implemented: Setting up Keycloak in OpenShift Security in Quarkus Applications via Keycloak Securing Vue.js Applications with Keycloak","title":"Blogs"},{"location":"SUMMARY/","text":"Summary \u00b6 Setup the IBM Cloud Environment \u00b6 Overview Access the Cluster Access IBM Cloud Shell and get the code Setup the IBM Cloud application environment \u00b6 Overview Exercise 1: Setup Istio Exercise 2: Expose Istio Ingress gateway Exercise 3: Expose the gateway via DNS with TLS enabled Exercise 4: Setup Keycloak Platform security with mTLS \u00b6 Exercise 1: Deploy microservices to Kubernetes Exercise 2: Secure microservices using Authentication with mTLS (Optional) Exercise 3: Authorization with Istio Authentication and Authorization with Keycloak and Quarkus \u00b6 (Optional) Exercise 1: Setup the web-application and Microservices locally Exercise 2: Authentication in Vue.js fronted application Exercise 3: Authorization in Quarkus application Additional Resources \u00b6 Known issues Blog posts related to security Cloud-Native-Starter project Cloud-Native-Starter project security Cloud-Native-Starter project reactive","title":"Summary"},{"location":"SUMMARY/#summary","text":"","title":"Summary"},{"location":"SUMMARY/#setup-the-ibm-cloud-environment","text":"Overview Access the Cluster Access IBM Cloud Shell and get the code","title":"Setup the IBM Cloud Environment"},{"location":"SUMMARY/#setup-the-ibm-cloud-application-environment","text":"Overview Exercise 1: Setup Istio Exercise 2: Expose Istio Ingress gateway Exercise 3: Expose the gateway via DNS with TLS enabled Exercise 4: Setup Keycloak","title":"Setup the IBM Cloud application environment"},{"location":"SUMMARY/#platform-security-with-mtls","text":"Exercise 1: Deploy microservices to Kubernetes Exercise 2: Secure microservices using Authentication with mTLS (Optional) Exercise 3: Authorization with Istio","title":"Platform security with mTLS"},{"location":"SUMMARY/#authentication-and-authorization-with-keycloak-and-quarkus","text":"(Optional) Exercise 1: Setup the web-application and Microservices locally Exercise 2: Authentication in Vue.js fronted application Exercise 3: Authorization in Quarkus application","title":"Authentication and Authorization with Keycloak and Quarkus"},{"location":"SUMMARY/#additional-resources","text":"Known issues Blog posts related to security Cloud-Native-Starter project Cloud-Native-Starter project security Cloud-Native-Starter project reactive","title":"Additional Resources"},{"location":"additional/additional/","text":"Additional Information \u00b6 Here you find additional help, something went wrong, known issues or just get some information. (Issue 1) In case your Cloud Shell session was closed \u00b6 Setup the major environment variables we need in the workshop. Solution : Follow these steps to setup the major environment variables we need in the workshop. Step 1: Go back to the open browser tab the open Kubernetes Cluster in the IBM Cloud web console. \u00b6 Now select Actions->Connect via CLI on the right-hand side. In the new window you see all steps to access your Kubernetes Cluster in a terminal session. You can easily copy and paste the commands. We will use these commands later to access the Kubernetes cluster in the IBM Cloud Shell. Step 2: Setup needed variable you maybe need in your lab \u00b6 ROOT_FOLDER of your project git clone https://github.com/IBM/cloud-native-starter.git cd cloud-native-starter/security ROOT_FOLDER = $( pwd ) echo $ROOT_FOLDER MYCLUSTER your cluster name export MYCLUSTER = YOUR-CLUSTER INGRESSGATEWAYIP needed to create a DNS export INGRESSGATEWAYIP = $( kubectl get svc -n istio-system | grep 'istio-ingressgateway' | awk '{print $4}' ) echo $INGRESSGATEWAYIP INGRESSSECRET we use for Istio Ingress Gateway configuration export INGRESSSECRET = export INGRESSSECRET = $( ibmcloud ks nlb-dns ls --cluster $MYCLUSTER | grep '0001' | awk '{print $5}' ) echo $INGRESSSECRET INGRESSURL we use to access for example the Cloud Native Starter application and Keycloak export INGRESSURL = $( ibmcloud ks nlb-dns ls --cluster $MYCLUSTER | awk '/-0001./ {print $1}' ) echo $INGRESSURL (Issue 2) You can't access the Kubernetes Dashboard \u00b6 When you open up your Kubernetes Dashboard from your cluster from the IBM Cloud WebConsole and you get following error message: It cloud be that you are logged on to two different IBM Cloud Accounts (your IBM Cloud account and the IBM Cloud workshop account ) in different browser tabs. Solution : Just make sure you are signed in to the IBM Cloud Workshop account. To ensure this, just reload the tab on your browser and check the account. Then if you use the correct account it should work. (Issue 3) Problems with your IBM Cloud Account \u00b6 If you have problems with your IBM Cloud Account please visit the FAQ page from the IBM Cloud support . For questions like: How do I resolve errors that occur when creating my account? Can I sign up for a free trial? and many more ... (Note) Find the Certificate Manager of your cluster \u00b6 IBM Cloud does create for you a free Certificate Manager service instance to manage the certificates for your Kubernetes cluster. Step 1: Copy the cluster ID \u00b6 Step 2: Find the resources related to this cluster ID \u00b6 Step 3: Inspect the given certificates \u00b6","title":"Known issues"},{"location":"additional/additional/#additional-information","text":"Here you find additional help, something went wrong, known issues or just get some information.","title":"Additional Information"},{"location":"additional/additional/#issue-1-in-case-your-cloud-shell-session-was-closed","text":"Setup the major environment variables we need in the workshop. Solution : Follow these steps to setup the major environment variables we need in the workshop.","title":"(Issue 1) In case your Cloud Shell session was closed"},{"location":"additional/additional/#step-1-go-back-to-the-open-browser-tab-the-open-kubernetes-cluster-in-the-ibm-cloud-web-console","text":"Now select Actions->Connect via CLI on the right-hand side. In the new window you see all steps to access your Kubernetes Cluster in a terminal session. You can easily copy and paste the commands. We will use these commands later to access the Kubernetes cluster in the IBM Cloud Shell.","title":"Step 1: Go back to the open browser tab the open Kubernetes Cluster in the IBM Cloud web console."},{"location":"additional/additional/#step-2-setup-needed-variable-you-maybe-need-in-your-lab","text":"ROOT_FOLDER of your project git clone https://github.com/IBM/cloud-native-starter.git cd cloud-native-starter/security ROOT_FOLDER = $( pwd ) echo $ROOT_FOLDER MYCLUSTER your cluster name export MYCLUSTER = YOUR-CLUSTER INGRESSGATEWAYIP needed to create a DNS export INGRESSGATEWAYIP = $( kubectl get svc -n istio-system | grep 'istio-ingressgateway' | awk '{print $4}' ) echo $INGRESSGATEWAYIP INGRESSSECRET we use for Istio Ingress Gateway configuration export INGRESSSECRET = export INGRESSSECRET = $( ibmcloud ks nlb-dns ls --cluster $MYCLUSTER | grep '0001' | awk '{print $5}' ) echo $INGRESSSECRET INGRESSURL we use to access for example the Cloud Native Starter application and Keycloak export INGRESSURL = $( ibmcloud ks nlb-dns ls --cluster $MYCLUSTER | awk '/-0001./ {print $1}' ) echo $INGRESSURL","title":"Step 2: Setup needed variable you maybe need in your lab"},{"location":"additional/additional/#issue-2-you-cant-access-the-kubernetes-dashboard","text":"When you open up your Kubernetes Dashboard from your cluster from the IBM Cloud WebConsole and you get following error message: It cloud be that you are logged on to two different IBM Cloud Accounts (your IBM Cloud account and the IBM Cloud workshop account ) in different browser tabs. Solution : Just make sure you are signed in to the IBM Cloud Workshop account. To ensure this, just reload the tab on your browser and check the account. Then if you use the correct account it should work.","title":"(Issue 2) You can't access the Kubernetes Dashboard"},{"location":"additional/additional/#issue-3-problems-with-your-ibm-cloud-account","text":"If you have problems with your IBM Cloud Account please visit the FAQ page from the IBM Cloud support . For questions like: How do I resolve errors that occur when creating my account? Can I sign up for a free trial? and many more ...","title":"(Issue 3) Problems with your IBM Cloud Account"},{"location":"additional/additional/#note-find-the-certificate-manager-of-your-cluster","text":"IBM Cloud does create for you a free Certificate Manager service instance to manage the certificates for your Kubernetes cluster.","title":"(Note) Find the Certificate Manager of your cluster"},{"location":"additional/additional/#step-1-copy-the-cluster-id","text":"","title":"Step 1: Copy the cluster ID"},{"location":"additional/additional/#step-2-find-the-resources-related-to-this-cluster-id","text":"","title":"Step 2: Find the resources related to this cluster ID"},{"location":"additional/additional/#step-3-inspect-the-given-certificates","text":"","title":"Step 3: Inspect the given certificates"},{"location":"app-env-exercise-01/","text":"Overview: Setup Istio and Keycloak \u00b6 We need Keycloak for authentication and authorization. And we need Istio to secure access to our services. In the following exercises we will: Install Istio on the IBM Cloud Kubernetes Service (IKS). We will use the Istio Ingress gateway to gain access to our sample application and to Keycloak externally with a DNS entry. We will secure the Istio Ingress gateway with HTTPS using a certificate that is automatically generated. Install Keycloak within the Istio Service Mesh.","title":"Overview"},{"location":"app-env-exercise-01/#overview-setup-istio-and-keycloak","text":"We need Keycloak for authentication and authorization. And we need Istio to secure access to our services. In the following exercises we will: Install Istio on the IBM Cloud Kubernetes Service (IKS). We will use the Istio Ingress gateway to gain access to our sample application and to Keycloak externally with a DNS entry. We will secure the Istio Ingress gateway with HTTPS using a certificate that is automatically generated. Install Keycloak within the Istio Service Mesh.","title":"Overview: Setup Istio and Keycloak"},{"location":"app-env-exercise-01/SETUP_ISTIO/","text":"Setup Istio \u00b6 Normally in a production size Kubernetes cluster on IBM Cloud we would install Istio as an Add-On. There are 5 Kubernetes add-ons available: Istio, Knative, Kubernetes Terminal, Diagnostic and Debug Tools, and Static Route. Istio installed via the add-on is a managed service. It creates a production grade Istio instance and it requires a cluster with at least 3 worker nodes with 4 CPUs and 16 GB of memory which our lab Kubernetes cluster doesn't have. Instead, in this lab we will install the Istio demo profile ourselves using istioctl and the Istio standalone operator. istioctl is available in IBM Cloud Shell, when we wrote these instructions it was at version 1.5.4 which means we will install Istio 1.5.4. Automated setup \u00b6 Step 1: Execute following script \u00b6 cd $ROOT_FOLDER bash $ROOT_FOLDER /IKS/istio-setup.sh Example output: ... NAME READY STATUS RESTARTS AGE grafana-5cc7f86765-bx7cg 1 /1 Running 0 7d21h istio-egressgateway-5c8f9897f7-bgvsb 1 /1 Running 0 7d21h istio-ingressgateway-65dd885d75-mg7dh 1 /1 Running 0 7d18h istio-tracing-8584b4d7f9-jnf2s 1 /1 Running 0 7d21h istiod-7d6dff85dd-nb7v6 1 /1 Running 0 7d21h kiali-696bb665-wp2kv 1 /1 Running 0 7d21h prometheus-564768879c-x5q7c 2 /2 Running 0 7d21h ------------------------------------------------------------------------ Check grafana Status: Running 2020 -08-11 13 :44:30 Status: grafana is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Check istiod Status: Running 2020 -08-11 13 :44:31 Status: istiod is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Check prometheus Status: Running 2020 -08-11 13 :44:32 Status: prometheus is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Check istio-egressgateway Status: Running 2020 -08-11 13 :44:32 Status: istio-egressgateway is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Check istio-ingressgateway Status: Running 2020 -08-11 13 :44:33 Status: istio-ingressgateway is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Check istio-tracing Status: Running 2020 -08-11 13 :44:34 Status: istio-tracing is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Replace telemetry config to expose nodeports ------------------------------------------------------------------------ service \"grafana\" deleted service \"kiali\" deleted service \"prometheus\" deleted service \"jaeger-query\" deleted ------------------------------------------------------------------------ Label namespace 'default' for auto injection ... FYI: Manual setup \u00b6 The following steps show the manual steps of the automated setup. This is just for your information, you don't need to run them! Step 1: Setup Istio with an operator \u00b6 The following commands do install the Istio operator, create a namespace for the Istio backplane, and start to installation of the Istio backplane. Operator istioctl operator init Namespace kubectl create ns istio-system Istio deployment kubectl apply -f istio.yaml Label default namespace for Istio pod auto-injection kubectl label namespace default istio-injection = enabled Step 2: Check the status of Istio deployment \u00b6 kubectl get pod -n istio-system When deployment is completed the result should look like this: NAME READY STATUS RESTARTS AGE grafana-5cc7f86765-65fc6 1 /1 Running 0 3m28s istio-egressgateway-5c8f9897f7-s8tfq 1 /1 Running 0 3m32s istio-ingressgateway-65dd885d75-vrcg8 1 /1 Running 0 3m29s istio-tracing-8584b4d7f9-7krd2 1 /1 Running 0 3m13s istiod-7d6dff85dd-29mjb 1 /1 Running 0 3m29s kiali-696bb665-8rrhr 1 /1 Running 0 3m12s prometheus-564768879c-2r87j 2 /2 Running 0 3m12s","title":"Lab 1. Setup Istio"},{"location":"app-env-exercise-01/SETUP_ISTIO/#setup-istio","text":"Normally in a production size Kubernetes cluster on IBM Cloud we would install Istio as an Add-On. There are 5 Kubernetes add-ons available: Istio, Knative, Kubernetes Terminal, Diagnostic and Debug Tools, and Static Route. Istio installed via the add-on is a managed service. It creates a production grade Istio instance and it requires a cluster with at least 3 worker nodes with 4 CPUs and 16 GB of memory which our lab Kubernetes cluster doesn't have. Instead, in this lab we will install the Istio demo profile ourselves using istioctl and the Istio standalone operator. istioctl is available in IBM Cloud Shell, when we wrote these instructions it was at version 1.5.4 which means we will install Istio 1.5.4.","title":"Setup Istio"},{"location":"app-env-exercise-01/SETUP_ISTIO/#automated-setup","text":"","title":"Automated setup"},{"location":"app-env-exercise-01/SETUP_ISTIO/#step-1-execute-following-script","text":"cd $ROOT_FOLDER bash $ROOT_FOLDER /IKS/istio-setup.sh Example output: ... NAME READY STATUS RESTARTS AGE grafana-5cc7f86765-bx7cg 1 /1 Running 0 7d21h istio-egressgateway-5c8f9897f7-bgvsb 1 /1 Running 0 7d21h istio-ingressgateway-65dd885d75-mg7dh 1 /1 Running 0 7d18h istio-tracing-8584b4d7f9-jnf2s 1 /1 Running 0 7d21h istiod-7d6dff85dd-nb7v6 1 /1 Running 0 7d21h kiali-696bb665-wp2kv 1 /1 Running 0 7d21h prometheus-564768879c-x5q7c 2 /2 Running 0 7d21h ------------------------------------------------------------------------ Check grafana Status: Running 2020 -08-11 13 :44:30 Status: grafana is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Check istiod Status: Running 2020 -08-11 13 :44:31 Status: istiod is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Check prometheus Status: Running 2020 -08-11 13 :44:32 Status: prometheus is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Check istio-egressgateway Status: Running 2020 -08-11 13 :44:32 Status: istio-egressgateway is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Check istio-ingressgateway Status: Running 2020 -08-11 13 :44:33 Status: istio-ingressgateway is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Check istio-tracing Status: Running 2020 -08-11 13 :44:34 Status: istio-tracing is Ready ------------------------------------------------------------------------ ------------------------------------------------------------------------ Replace telemetry config to expose nodeports ------------------------------------------------------------------------ service \"grafana\" deleted service \"kiali\" deleted service \"prometheus\" deleted service \"jaeger-query\" deleted ------------------------------------------------------------------------ Label namespace 'default' for auto injection ...","title":"Step 1: Execute following script"},{"location":"app-env-exercise-01/SETUP_ISTIO/#fyi-manual-setup","text":"The following steps show the manual steps of the automated setup. This is just for your information, you don't need to run them!","title":"FYI: Manual setup"},{"location":"app-env-exercise-01/SETUP_ISTIO/#step-1-setup-istio-with-an-operator","text":"The following commands do install the Istio operator, create a namespace for the Istio backplane, and start to installation of the Istio backplane. Operator istioctl operator init Namespace kubectl create ns istio-system Istio deployment kubectl apply -f istio.yaml Label default namespace for Istio pod auto-injection kubectl label namespace default istio-injection = enabled","title":"Step 1: Setup Istio with an operator"},{"location":"app-env-exercise-01/SETUP_ISTIO/#step-2-check-the-status-of-istio-deployment","text":"kubectl get pod -n istio-system When deployment is completed the result should look like this: NAME READY STATUS RESTARTS AGE grafana-5cc7f86765-65fc6 1 /1 Running 0 3m28s istio-egressgateway-5c8f9897f7-s8tfq 1 /1 Running 0 3m32s istio-ingressgateway-65dd885d75-vrcg8 1 /1 Running 0 3m29s istio-tracing-8584b4d7f9-7krd2 1 /1 Running 0 3m13s istiod-7d6dff85dd-29mjb 1 /1 Running 0 3m29s kiali-696bb665-8rrhr 1 /1 Running 0 3m12s prometheus-564768879c-2r87j 2 /2 Running 0 3m12s","title":"Step 2: Check the status of Istio deployment"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS/","text":"Expose the Istio Ingress gateway via DNS \u00b6 The following procedures are platform specific and work with a \"standard classic\" Kubernetes Cluster provided by the IBM Cloud Kubernetes Service (IKS) on the IBM Cloud. If you are using a VPC based or a free (\"Lite\") Kubernetes Cluster on the IBM Cloud or another Cloud provider or something like Minikube, the following sections will not work! When you install Istio on a Kubernetes Cluster on IBM Cloud, the Istio Ingress is created with a Kubernetes service of type LoadBalancer -- this is called a Network Load Balancer or NLB on IBM Cloud. A \"floating\" IP address is assigned to it through which it can be reached on the public Internet. In this section we will assign a subdomain DNS entry for this IP address so that the Istio Ingress can be accessed using a URL. Automated setup \u00b6 Step 1: Ensure you exported the $MYCLUSTER variable \u00b6 echo $MYCLUSTER If this isn`t the case run, following commands: Copy your cluster name from the output ibmcloud ks cluster ls Export the $MYCLUSTER variable export MYCLUSTER = your_pre_provisioned_clustername Step 2: Execute following script \u00b6 cd $ROOT_FOLDER bash IKS/istio-setup-ingress-gateway.sh Example output: ... OK NLB hostname was created as harald-uebele-k8s-fra05-***-0001.us-south.containers.appdomain.cloud ------------------------------------------------------------------------ Ingress-URL: harald-uebele-k8s-fra05-***-0001.us-south.containers.appdomain.cloud Cluster Name: harald-uebele-k8s-fra05 ... Step 3: Create a $INGRESSURL variable for later usage \u00b6 Insert your YOUR_INGRESSURL value. export INGRESSURL = YOUR_INGRESSURL echo $INGRESSURL FYI: Manual setup \u00b6 The following steps show the manual steps of the automated setup. This is just for your information, you don't need to run them! Step 1: Get public IP \u00b6 When we install Istio on our pre-provisioned Kubernetes Clusters on IBM Cloud, the Istio Ingress is created with a Kubernetes service of type LoadBalancer and is assigned a \"floating\" IP address through which it can be reached on the public Internet. You can determine this address with the following command: cd $ROOT_FOLDER /IKS kubectl get svc -n istio-system | grep istio-ingressgateway Output for example: istio-ingressgateway LoadBalancer 172 .21.213.52 149 .***.131.*** 15020 :31754/TCP,... Step 2: Save public IP address \u00b6 Our Ingress gateway is in fact of type LoadBalancer, the second IP address of the example 149.***.131.*** is the external (public) IP address. We need this public IP address in the next command. export INGRESSGATEWAYIP = 149 .***.131.*** Step 3: Create a DNS subdomain \u00b6 To create a DNS subdomain -- a URL -- for the Ingress gateway use the following command: echo $MYCLUSTER ibmcloud ks nlb-dns create classic --cluster $MYCLUSTER --ip $INGRESSGATEWAYIP The new subdomain will have the form [cluster name]-[globally unique hash]-[sequence].[region].containers.appdomain.cloud . The output should look like this: OK NLB hostname was created as harald-uebele-k8s-fra05-********************-0001.eu-de.containers.appdomain.cloud Step 4: Save DNS subdomain as $INGRESSURL \u00b6 This will be the URL we will use later to access Keycloak and our sample application. Copy the URL and paste it into an environment variable: export INGRESSURL = harald-uebele-k8s-fra05-********************-0001.eu-de.containers.appdomain.cloud","title":"Lab 2. Expose Istio Ingress gateway"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS/#expose-the-istio-ingress-gateway-via-dns","text":"The following procedures are platform specific and work with a \"standard classic\" Kubernetes Cluster provided by the IBM Cloud Kubernetes Service (IKS) on the IBM Cloud. If you are using a VPC based or a free (\"Lite\") Kubernetes Cluster on the IBM Cloud or another Cloud provider or something like Minikube, the following sections will not work! When you install Istio on a Kubernetes Cluster on IBM Cloud, the Istio Ingress is created with a Kubernetes service of type LoadBalancer -- this is called a Network Load Balancer or NLB on IBM Cloud. A \"floating\" IP address is assigned to it through which it can be reached on the public Internet. In this section we will assign a subdomain DNS entry for this IP address so that the Istio Ingress can be accessed using a URL.","title":"Expose the Istio Ingress gateway via DNS"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS/#automated-setup","text":"","title":"Automated setup"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS/#step-1-ensure-you-exported-the-mycluster-variable","text":"echo $MYCLUSTER If this isn`t the case run, following commands: Copy your cluster name from the output ibmcloud ks cluster ls Export the $MYCLUSTER variable export MYCLUSTER = your_pre_provisioned_clustername","title":"Step 1: Ensure you exported the $MYCLUSTER variable"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS/#step-2-execute-following-script","text":"cd $ROOT_FOLDER bash IKS/istio-setup-ingress-gateway.sh Example output: ... OK NLB hostname was created as harald-uebele-k8s-fra05-***-0001.us-south.containers.appdomain.cloud ------------------------------------------------------------------------ Ingress-URL: harald-uebele-k8s-fra05-***-0001.us-south.containers.appdomain.cloud Cluster Name: harald-uebele-k8s-fra05 ...","title":"Step 2: Execute following script"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS/#step-3-create-a-ingressurl-variable-for-later-usage","text":"Insert your YOUR_INGRESSURL value. export INGRESSURL = YOUR_INGRESSURL echo $INGRESSURL","title":"Step 3: Create a $INGRESSURL variable for later usage"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS/#fyi-manual-setup","text":"The following steps show the manual steps of the automated setup. This is just for your information, you don't need to run them!","title":"FYI: Manual setup"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS/#step-1-get-public-ip","text":"When we install Istio on our pre-provisioned Kubernetes Clusters on IBM Cloud, the Istio Ingress is created with a Kubernetes service of type LoadBalancer and is assigned a \"floating\" IP address through which it can be reached on the public Internet. You can determine this address with the following command: cd $ROOT_FOLDER /IKS kubectl get svc -n istio-system | grep istio-ingressgateway Output for example: istio-ingressgateway LoadBalancer 172 .21.213.52 149 .***.131.*** 15020 :31754/TCP,...","title":"Step 1: Get public IP"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS/#step-2-save-public-ip-address","text":"Our Ingress gateway is in fact of type LoadBalancer, the second IP address of the example 149.***.131.*** is the external (public) IP address. We need this public IP address in the next command. export INGRESSGATEWAYIP = 149 .***.131.***","title":"Step 2: Save public IP address"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS/#step-3-create-a-dns-subdomain","text":"To create a DNS subdomain -- a URL -- for the Ingress gateway use the following command: echo $MYCLUSTER ibmcloud ks nlb-dns create classic --cluster $MYCLUSTER --ip $INGRESSGATEWAYIP The new subdomain will have the form [cluster name]-[globally unique hash]-[sequence].[region].containers.appdomain.cloud . The output should look like this: OK NLB hostname was created as harald-uebele-k8s-fra05-********************-0001.eu-de.containers.appdomain.cloud","title":"Step 3: Create a DNS subdomain"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS/#step-4-save-dns-subdomain-as-ingressurl","text":"This will be the URL we will use later to access Keycloak and our sample application. Copy the URL and paste it into an environment variable: export INGRESSURL = harald-uebele-k8s-fra05-********************-0001.eu-de.containers.appdomain.cloud","title":"Step 4: Save DNS subdomain as $INGRESSURL"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/","text":"Expose the Istio Ingress gateway via DNS with TLS enabled \u00b6 In the previous exercise we created a DNS entry for the Ingress controller . In this exercise we enable secure HTTPS access via the Istio Ingress gateway on port 443. The procedure we will use in this exercise is documented in the IBM Cloud documentation here . There is also generic documentation about Secure Gateways available in the Istio documentation. The Istio Ingress gateway on the IBM Cloud is of type LoadBalancer and in the last exercise we created a DNS entry for it. In the background this also automatically generates a \"Let's encrypt\" certificate and private key for HTTPS/TLS traffic and it creates a Kubernetes secret of type 'tls' containing this certificate and key. The secret is created in the 'default' namespace. The Istio Ingress pod is running in the 'istio-system' namespace. The following info is from the Kubernetes documentation: Secret resources reside in a namespace. Secrets can only be referenced by Pods in that same namespace. Therefore we need to pull certificate and key from the secret in the 'default' namespace, change its name, and create a new secret in the 'istio-system' namespace so that the Istio Ingress gateway can use it. Step 1: Verify clustername \u00b6 echo $MYCLUSTER Step 2: List the DNS subdomains \u00b6 cd $ROOT_FOLDER /IKS ibmcloud ks nlb-dns ls --cluster $MYCLUSTER Example output: Hostname IP ( s ) Health Monitor SSL Cert Status SSL Cert Secret Name Secret Namespace harald-uebele-k8s-fra05-***-0000.***.cloud 169 .46.52.50,169.48.97.58 enabled created harald-uebele-k8s-fra05-****-0000 default harald-uebele-k8s-fra05-***-0001.***.cloud 169 .48.97.62 None created harald-uebele-k8s-fra05-****-0001 default Note: IBM Cloud does create for you a free Certificate Manager service instance, to manage the certificates for your Kubernetes cluster. For more details please visit the additional section . Step 3: Save Ingress secret \u00b6 You should see 2 entries, the first is for the Kubernetes Ingress that is created for you when the cluster is created. The second is the Istio Ingress subdomain you created in the last exercise. Copy the \"SSL Cert Secret Name\" (should end on -0001) and paste it into another environment variable: export INGRESSSECRET = harald-uebele-k8s-fra05-***-0001 Step 3: Pull the secret and save it into a file mysecret.yaml \u00b6 kubectl get secret $INGRESSSECRET --namespace default --export -o yaml > mysecret.yaml Step 4: Edit the mysecret.yaml \u00b6 The secret was created in the 'default' namespace. In order to use it with Istio, we want to modify the name and place it in the 'istio-system' namespace. Open the mysecret.yaml file in an editor, e.g. nano , change the value of the secret name from ... something like name: [your-clustername]-******-0001 to ... name: istio-ingressgateway-certs and save the file. nano mysecret.yaml Your changed file should look similar to this example, the changed line is line 12 ( istio-ingressgateway-certs ): apiVersion: v1 data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk... tls.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS... kind: Secret metadata: annotations: ingress.cloud.ibm.com/cert-source: ibm kubectl.kubernetes.io/last-applied-configuration: | {\"apiVersion\":\"v1\",\"data\":{\"tls.crt\":\"LS0tLS1CRUdJTiBDRVJUSUZJQ0FU... creationTimestamp: null name: istio-ingressgateway-certs selfLink: /api/v1/namespaces/default/secrets/harald-uebele-k8s-***************-0001 type: Opaque Step 5: Load and activate the secret with these commands \u00b6 Here the second command deletes the Istio Ingress pod to force it to reload and use the the newly created secret `istio-ingressgateway-certs. kubectl apply -f ./mysecret.yaml -n istio-system kubectl delete pod -n istio-system -l istio = ingressgateway Optional: You can verfiy the result also in the Kubernetes Dashboard. Here you can see our newly created secret Default Namespae Istio-System Namespace Step 6: Get the $INGRESSURL you obtained in the last exercise and copy or note the value \u00b6 echo $INGRESSURL Note: In case you did the automated setup and you don't have the $INGRESSURL use this command to get the URL: export INGRESSURL = $( ibmcloud ks nlb-dns ls --cluster $MYCLUSTER | awk '/-0001./ {print $1}' ) echo $INGRESSURL Step 7: Edit the file istio-ingress-tls.yaml \u00b6 Edit the file istio-ingress-tls.yaml: cd $ROOT_FOLDER /IKS nano istio-ingress-tls.yaml Replace the 2 occurances of wildcard \"*\", one in the Gateway definition, one in the VirtualService definition and save the file with the $INGRESSURL value. Watch out for the correct indents, this is YAML! ... servers: - port: number: 443 name: https protocol: HTTPS tls: mode: SIMPLE serverCertificate: /etc/istio/ingressgateway-certs/tls.crt privateKey: /etc/istio/ingressgateway-certs/tls.key hosts: \"*\" ... apiVersion: networking.istio.io/v1alpha3kind: VirtualService metadata: name: virtualservice-ingress spec: hosts: - \"*\" gateways: ... This creates 2 Istio objects: Gateway and VirtualService, both in the default namespace. The Gateway definition basically allows to direct requests via HTTPS to services in the default namespace. The VirtualService definition for this Gateway uses matching rules to map specific paths/URIs to services that do not exist at the moment, we will create them later. If you look in the YAML file, you can see 3 \"match\" rules, they are all based on the \"hosts\" definition which is the Ingress URL: https://INGRESSURL/auth routes to the Keycloak service on port 8080 https://INGRESSURL/articles routes to the Web-API service on port 8081 https://INGRESSURL , the root ( / ) without a path, routes to the Web-App on port 80, this is the service that delivers the frontend app to the browser Step 8: Apply the change \u00b6 This last step, replacing the wildcard host \"*\" with the correct DNS name, is not really necessary. The Ingress Gateway would work with the wildcard, too, but now you have a correct configuration that is more secure. And this is what this workshop is about, isn't it? istio-ingress-tls.yaml creates an Istio Gateway configuration using the TLS certificate we stored in a Kubernetes secret before. kubectl apply -f istio-ingress-tls.yaml Note: There is a blog on the Istio page that describes how to Direct encrypted traffic from IBM Cloud Kubernetes Service Ingress to Istio Ingress Gateway . With this scenario you can have non-Istio secured services communicate with services secured by Istio, e.g. while you are migrating your application into Istio. This blog also contains an important piece of information regarding the Let's Encrypt certificates used: The certificates provided by IKS expire every 90 days and are automatically renewed by IKS 37 days before they expire. You will have to recreate the secrets by rerunning the instructions of this section every time the secrets provided by IKS are updated. You may want to use scripts or operators to automate this and keep the secrets in sync. Answering questions you maybe have \u00b6 Here are some questions you may have regarding TLS (HTTPS): Question 1 : Why can we access our application with TLS https://... ? \u00b6 Answer 1: We prepared this during the setup of the IBM Cloud Application Environment in exercise 3 \u00b6 We let IBM Cloud create a DNS entry and Let's Encrypt certificate We added this certificate to the Istio Ingress We added the DNS name (host) to the Istio Ingress Gateway definition We added it also to the VirtualService definition that configures the Gateway and here is our secret, look at IKS/istio-ingress-tls.yaml : The Gateway definition specifies HTTPS only and points to the location of the TLS certificates. The VirtualService definition specifies 3 rules: If call the DNS entry / Ingress URL with /auth it will direct to keycloak. With /articles it will direct to the web-api Without an path it directs to the web-app itself. Question 2: We use https in the browser but everything behind the Istio Ingress is http only, unencrypted? \u00b6 Answer 2: \u00b6 That is the beauty of Istio! Yes, we make our requests via http which is most obvious with the web-app that is called on port 80. But Istio injects an Envy proxy into every pod in the default namespace automatically. We defined this when we set up Istio, it is in the script you ran. There is also an Envoy proxy in the Istio Ingress pod. Communication between the Envoys is always encrypted, Istio uses mTLS. And all our requests flow through the proxies so even if the communication between e.g. web-api and articles is using http, the communication between the web-api pod and the articles pod is secure. Question 3: Is this safe? \u00b6 Answer 3: \u00b6 No, at least not not totally. By default, after installation, Istio uses mTLS in PERMISSIVE mode. This allows to test and gradually secure your microservices mesh. In the later exercise Secure microservices with strict mTLS you will see how to change that.","title":"Lab 3. Expose the gateway via DNS with TLS enabled"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#expose-the-istio-ingress-gateway-via-dns-with-tls-enabled","text":"In the previous exercise we created a DNS entry for the Ingress controller . In this exercise we enable secure HTTPS access via the Istio Ingress gateway on port 443. The procedure we will use in this exercise is documented in the IBM Cloud documentation here . There is also generic documentation about Secure Gateways available in the Istio documentation. The Istio Ingress gateway on the IBM Cloud is of type LoadBalancer and in the last exercise we created a DNS entry for it. In the background this also automatically generates a \"Let's encrypt\" certificate and private key for HTTPS/TLS traffic and it creates a Kubernetes secret of type 'tls' containing this certificate and key. The secret is created in the 'default' namespace. The Istio Ingress pod is running in the 'istio-system' namespace. The following info is from the Kubernetes documentation: Secret resources reside in a namespace. Secrets can only be referenced by Pods in that same namespace. Therefore we need to pull certificate and key from the secret in the 'default' namespace, change its name, and create a new secret in the 'istio-system' namespace so that the Istio Ingress gateway can use it.","title":"Expose the Istio Ingress gateway via DNS with TLS enabled"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#step-1-verify-clustername","text":"echo $MYCLUSTER","title":"Step 1: Verify clustername"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#step-2-list-the-dns-subdomains","text":"cd $ROOT_FOLDER /IKS ibmcloud ks nlb-dns ls --cluster $MYCLUSTER Example output: Hostname IP ( s ) Health Monitor SSL Cert Status SSL Cert Secret Name Secret Namespace harald-uebele-k8s-fra05-***-0000.***.cloud 169 .46.52.50,169.48.97.58 enabled created harald-uebele-k8s-fra05-****-0000 default harald-uebele-k8s-fra05-***-0001.***.cloud 169 .48.97.62 None created harald-uebele-k8s-fra05-****-0001 default Note: IBM Cloud does create for you a free Certificate Manager service instance, to manage the certificates for your Kubernetes cluster. For more details please visit the additional section .","title":"Step 2: List the DNS subdomains"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#step-3-save-ingress-secret","text":"You should see 2 entries, the first is for the Kubernetes Ingress that is created for you when the cluster is created. The second is the Istio Ingress subdomain you created in the last exercise. Copy the \"SSL Cert Secret Name\" (should end on -0001) and paste it into another environment variable: export INGRESSSECRET = harald-uebele-k8s-fra05-***-0001","title":"Step 3: Save Ingress secret"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#step-3-pull-the-secret-and-save-it-into-a-file-mysecretyaml","text":"kubectl get secret $INGRESSSECRET --namespace default --export -o yaml > mysecret.yaml","title":"Step 3: Pull the secret and save it into a file mysecret.yaml"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#step-4-edit-the-mysecretyaml","text":"The secret was created in the 'default' namespace. In order to use it with Istio, we want to modify the name and place it in the 'istio-system' namespace. Open the mysecret.yaml file in an editor, e.g. nano , change the value of the secret name from ... something like name: [your-clustername]-******-0001 to ... name: istio-ingressgateway-certs and save the file. nano mysecret.yaml Your changed file should look similar to this example, the changed line is line 12 ( istio-ingressgateway-certs ): apiVersion: v1 data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk... tls.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS... kind: Secret metadata: annotations: ingress.cloud.ibm.com/cert-source: ibm kubectl.kubernetes.io/last-applied-configuration: | {\"apiVersion\":\"v1\",\"data\":{\"tls.crt\":\"LS0tLS1CRUdJTiBDRVJUSUZJQ0FU... creationTimestamp: null name: istio-ingressgateway-certs selfLink: /api/v1/namespaces/default/secrets/harald-uebele-k8s-***************-0001 type: Opaque","title":"Step 4: Edit the mysecret.yaml"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#step-5-load-and-activate-the-secret-with-these-commands","text":"Here the second command deletes the Istio Ingress pod to force it to reload and use the the newly created secret `istio-ingressgateway-certs. kubectl apply -f ./mysecret.yaml -n istio-system kubectl delete pod -n istio-system -l istio = ingressgateway Optional: You can verfiy the result also in the Kubernetes Dashboard. Here you can see our newly created secret Default Namespae Istio-System Namespace","title":"Step 5: Load and activate the secret with these commands"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#step-6-get-the-ingressurl-you-obtained-in-the-last-exercise-and-copy-or-note-the-value","text":"echo $INGRESSURL Note: In case you did the automated setup and you don't have the $INGRESSURL use this command to get the URL: export INGRESSURL = $( ibmcloud ks nlb-dns ls --cluster $MYCLUSTER | awk '/-0001./ {print $1}' ) echo $INGRESSURL","title":"Step 6: Get the $INGRESSURL you obtained in the last exercise and copy or note the value"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#step-7-edit-the-file-istio-ingress-tlsyaml","text":"Edit the file istio-ingress-tls.yaml: cd $ROOT_FOLDER /IKS nano istio-ingress-tls.yaml Replace the 2 occurances of wildcard \"*\", one in the Gateway definition, one in the VirtualService definition and save the file with the $INGRESSURL value. Watch out for the correct indents, this is YAML! ... servers: - port: number: 443 name: https protocol: HTTPS tls: mode: SIMPLE serverCertificate: /etc/istio/ingressgateway-certs/tls.crt privateKey: /etc/istio/ingressgateway-certs/tls.key hosts: \"*\" ... apiVersion: networking.istio.io/v1alpha3kind: VirtualService metadata: name: virtualservice-ingress spec: hosts: - \"*\" gateways: ... This creates 2 Istio objects: Gateway and VirtualService, both in the default namespace. The Gateway definition basically allows to direct requests via HTTPS to services in the default namespace. The VirtualService definition for this Gateway uses matching rules to map specific paths/URIs to services that do not exist at the moment, we will create them later. If you look in the YAML file, you can see 3 \"match\" rules, they are all based on the \"hosts\" definition which is the Ingress URL: https://INGRESSURL/auth routes to the Keycloak service on port 8080 https://INGRESSURL/articles routes to the Web-API service on port 8081 https://INGRESSURL , the root ( / ) without a path, routes to the Web-App on port 80, this is the service that delivers the frontend app to the browser","title":"Step 7: Edit the file istio-ingress-tls.yaml"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#step-8-apply-the-change","text":"This last step, replacing the wildcard host \"*\" with the correct DNS name, is not really necessary. The Ingress Gateway would work with the wildcard, too, but now you have a correct configuration that is more secure. And this is what this workshop is about, isn't it? istio-ingress-tls.yaml creates an Istio Gateway configuration using the TLS certificate we stored in a Kubernetes secret before. kubectl apply -f istio-ingress-tls.yaml Note: There is a blog on the Istio page that describes how to Direct encrypted traffic from IBM Cloud Kubernetes Service Ingress to Istio Ingress Gateway . With this scenario you can have non-Istio secured services communicate with services secured by Istio, e.g. while you are migrating your application into Istio. This blog also contains an important piece of information regarding the Let's Encrypt certificates used: The certificates provided by IKS expire every 90 days and are automatically renewed by IKS 37 days before they expire. You will have to recreate the secrets by rerunning the instructions of this section every time the secrets provided by IKS are updated. You may want to use scripts or operators to automate this and keep the secrets in sync.","title":"Step 8: Apply the change"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#answering-questions-you-maybe-have","text":"Here are some questions you may have regarding TLS (HTTPS):","title":"Answering questions you maybe have"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#question-1-why-can-we-access-our-application-with-tls-https","text":"","title":"Question 1: Why can we access our application with TLS https://... ?"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#answer-1-we-prepared-this-during-the-setup-of-the-ibm-cloud-application-environment-in-exercise-3","text":"We let IBM Cloud create a DNS entry and Let's Encrypt certificate We added this certificate to the Istio Ingress We added the DNS name (host) to the Istio Ingress Gateway definition We added it also to the VirtualService definition that configures the Gateway and here is our secret, look at IKS/istio-ingress-tls.yaml : The Gateway definition specifies HTTPS only and points to the location of the TLS certificates. The VirtualService definition specifies 3 rules: If call the DNS entry / Ingress URL with /auth it will direct to keycloak. With /articles it will direct to the web-api Without an path it directs to the web-app itself.","title":"Answer 1: We prepared this during the setup of the IBM Cloud Application Environment in exercise 3"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#question-2-we-use-https-in-the-browser-but-everything-behind-the-istio-ingress-is-http-only-unencrypted","text":"","title":"Question 2: We use https in the browser but everything behind the Istio Ingress is http only, unencrypted?"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#answer-2","text":"That is the beauty of Istio! Yes, we make our requests via http which is most obvious with the web-app that is called on port 80. But Istio injects an Envy proxy into every pod in the default namespace automatically. We defined this when we set up Istio, it is in the script you ran. There is also an Envoy proxy in the Istio Ingress pod. Communication between the Envoys is always encrypted, Istio uses mTLS. And all our requests flow through the proxies so even if the communication between e.g. web-api and articles is using http, the communication between the web-api pod and the articles pod is secure.","title":"Answer 2:"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#question-3-is-this-safe","text":"","title":"Question 3: Is this safe?"},{"location":"app-env-exercise-01/SETUP_ISTIO_INGRESS_TLS/#answer-3","text":"No, at least not not totally. By default, after installation, Istio uses mTLS in PERMISSIVE mode. This allows to test and gradually secure your microservices mesh. In the later exercise Secure microservices with strict mTLS you will see how to change that.","title":"Answer 3:"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/","text":"Setup Keycloak \u00b6 These setup instractions are based on Keycloak - Guide - Keycloak on Kubernetes . The instructions go into installing an Ingress for Keycloak. But we have Istio installed and we will be using the Istio Ingress to access Keycloak externally. The original keycloak.yaml is modified and the NodePort has been removed. Note: This is a \"ephemeral\" installation of Keycloak, there is no database used for persistance. Sufficient for a workshop but not suitable for production use! Step 1: Deploy Keycloak \u00b6 cd $ROOT_FOLDER /IKS kubectl apply -f keycloak.yaml Step 2: Wait until the Keycloak Pod is started \u00b6 kubectl get pods Step 3: Access Keycloak \u00b6 Get the Keycloak URL and open the URL in your browser: echo \"https://\" $INGRESSURL \"/auth\" Note: This will work because we created a VirtualService in the previous exercise that maps the /auth URI to the Keycloak service. Step 4: Try to logon to Keycloak \u00b6 Click on Administration Console . Login In with username admin and password admin . Step 5: Create realm \u00b6 For the workshop we need our pre-configured realm, we will create the realm using a bash script. Verify your existing environment varibles cd $ROOT_FOLDER /IKS echo $MYCLUSTER echo $INGRESSURL echo $INGRESSSECRET Execute the bash script bash keycloak-create-realm.sh Example output: ------------------------------------------------------------------------ The realm is created. Open following link in your browser: https://harald-uebele-k8s-fra05-********************-0001/auth/admin/master/console/#/realms/quarkus ------------------------------------------------------------------------ Step 6: Verify the newly created realm \u00b6 Try to create an access token, this requires the $INGRESSURL environment variable to be set: curl -d \"username=alice\" -d \"password=alice\" -d \"grant_type=password\" -d \"client_id=frontend\" https:// $INGRESSURL /auth/realms/quarkus/protocol/openid-connect/token | sed -n 's|.*\"access_token\":\"\\([^\"]*\\)\".*|\\1|p' Note: The image shows you in Kiali that we access Keycloak throuh our istio-ingressgateway . This is not a part of your hands-on tasks. Congratulations, you have successfully completed the Setup Application environment . Awesome Optional steps to verify the configuration \u00b6 STEP 1: Verify the name quarkus of the imported realm \u00b6 STEP 2: Verify the imported realm settings \u00b6 STEP 3: Press view all users \u00b6 You should see following users: admin , alice , jdoe STEP 4: Verify the role mapping \u00b6","title":"Lab 4. Setup Keycloak"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#setup-keycloak","text":"These setup instractions are based on Keycloak - Guide - Keycloak on Kubernetes . The instructions go into installing an Ingress for Keycloak. But we have Istio installed and we will be using the Istio Ingress to access Keycloak externally. The original keycloak.yaml is modified and the NodePort has been removed. Note: This is a \"ephemeral\" installation of Keycloak, there is no database used for persistance. Sufficient for a workshop but not suitable for production use!","title":"Setup Keycloak"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#step-1-deploy-keycloak","text":"cd $ROOT_FOLDER /IKS kubectl apply -f keycloak.yaml","title":"Step 1: Deploy Keycloak"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#step-2-wait-until-the-keycloak-pod-is-started","text":"kubectl get pods","title":"Step 2: Wait until the Keycloak Pod is started"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#step-3-access-keycloak","text":"Get the Keycloak URL and open the URL in your browser: echo \"https://\" $INGRESSURL \"/auth\" Note: This will work because we created a VirtualService in the previous exercise that maps the /auth URI to the Keycloak service.","title":"Step 3: Access Keycloak"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#step-4-try-to-logon-to-keycloak","text":"Click on Administration Console . Login In with username admin and password admin .","title":"Step 4: Try to logon to Keycloak"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#step-5-create-realm","text":"For the workshop we need our pre-configured realm, we will create the realm using a bash script. Verify your existing environment varibles cd $ROOT_FOLDER /IKS echo $MYCLUSTER echo $INGRESSURL echo $INGRESSSECRET Execute the bash script bash keycloak-create-realm.sh Example output: ------------------------------------------------------------------------ The realm is created. Open following link in your browser: https://harald-uebele-k8s-fra05-********************-0001/auth/admin/master/console/#/realms/quarkus ------------------------------------------------------------------------","title":"Step 5: Create realm"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#step-6-verify-the-newly-created-realm","text":"Try to create an access token, this requires the $INGRESSURL environment variable to be set: curl -d \"username=alice\" -d \"password=alice\" -d \"grant_type=password\" -d \"client_id=frontend\" https:// $INGRESSURL /auth/realms/quarkus/protocol/openid-connect/token | sed -n 's|.*\"access_token\":\"\\([^\"]*\\)\".*|\\1|p' Note: The image shows you in Kiali that we access Keycloak throuh our istio-ingressgateway . This is not a part of your hands-on tasks. Congratulations, you have successfully completed the Setup Application environment . Awesome","title":"Step 6: Verify the newly created realm"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#optional-steps-to-verify-the-configuration","text":"","title":"Optional steps to verify the configuration"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#step-1-verify-the-name-quarkusof-the-imported-realm","text":"","title":"STEP 1: Verify the name quarkusof the imported realm"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#step-2-verify-the-imported-realm-settings","text":"","title":"STEP 2: Verify the imported realm settings"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#step-3-press-view-all-users","text":"You should see following users: admin , alice , jdoe","title":"STEP 3: Press view all users"},{"location":"app-env-exercise-01/SETUP_KEYCLOAK/#step-4-verify-the-role-mapping","text":"","title":"STEP 4: Verify the role mapping"},{"location":"app-sec-exercise-01/","text":"Setup the web-application and Microservices locally \u00b6 To run these optional exercises you need to ensure you have installed the following tools on your local machine and you can run them in your terminal sessions. git 2.24.1 or higher yarn 1.22.4 or higher Node.js v14.6.0 or higher Apache Maven 3.6.3 Docker 3.0.4 or higher (running Keycloak locally) Java 9 or higher Architecture \u00b6 Here is the local architecture whichs shows the Web-App and the two Microservices Web-API and Articles are running on your local machine in terminal sessions. Keycloak is running on Kubernetes on IBM Cloud. The gif shows the logon to the example web frontend application. This is the simplified sequence which happens in the background: When we invoke the web frontend on ` http://localhost:8080 we will be routed to login dialog provided by the Keyloak server. After the successfully Keycloak authentication we will be redirected to the web frontend and the frontend gets an access-token. The access-token contains the needed information for the authorization at the Java microservice Web-API and the user information. The web frontend extracts and displays the username. Then the web fronted uses the access-token to invoke the Web-API Microservice endpoint to get the articles and displays the Articles. YouTube video related to the workshop \u00b6 Step 1: Clone the project to your local machine \u00b6 git clone https://github.com/IBM/cloud-native-starter.git cd cloud-native-starter/security ROOT_FOLDER = $( pwd ) (Optional) Setup Keycloak locally \u00b6 If you have your Keycloak running on Kubernetes you just skip to setup Web-App . In this part we will setup Keycloak locally. We will run a local Keycloak Docker container and reuse an existing realm configuration. The image below shows the relevant elements we will use later. Step 1: Start Keycloak Docker image local \u00b6 Open the first terminal session and enter following command: docker run -it -e KEYCLOAK_USER = admin -e KEYCLOAK_PASSWORD = admin -p 8282 :8080 jboss/keycloak:9.0.2 Note: We use here KEYCLOAK_USER=admin KEYCLOAK_PASSWORD=admin 8282:8080 port forwarding keycloak:9.0.2 container image Step 2: Import the existing realm configuration \u00b6 Open the Keycloak in a browser select the Administration Console Use following URL: http://localhost:8282/ Login to using the URL in your browser with user/admin and password/admin Select Add realm Choose for import Select file and open the quarkus-realm.json . Step 3: Press view all users \u00b6 You should see following users: admin , alice , jdoe Step 4: Verify the role mapping \u00b6 Setup Web-App \u00b6 Step 1: Configure web-app \u00b6 Now insert Keycloak URL /auth in main.js (`http://localhost:8282) and save the changes. cd $ROOT_FOLDER /web-app/src nano main.js Example: if ( currentHostname . indexOf ( 'localhost' ) > - 1 ) { urls = { api : 'http://localhost:8081/' , login : 'https://YOUR_URL/auth' // insert your http or https://<KeycloakURL>/auth } store . commit ( \"setAPIAndLogin\" , urls ); } Step 2: Run the web-app \u00b6 Open the second terminal session and start the application on port 8080. cd $ROOT_FOLDER /web-app yarn install yarn serve Setup Web-Api \u00b6 Step 1: Configure web-api-secure \u00b6 Insert your the auth-server-url URL of your Keycloak instance in application.properties file and save the file. Therefore you use the Keycloak URL you got during the setup of Keycloak on IBM Cloud. cd $ROOT_FOLDER /web-api-secure/src/main/resources nano application.properties Example: // When running locally, uncomment the next line, add your Keycloak URL, must end on '/auth/realms/quarkus' quarkus . oidc . auth - server - url = https : //YOUR_URL/auth/realms/quarkus quarkus . oidc . client - id = backend - service quarkus . oidc . credentials . secret = secret quarkus . http . port = 8081 quarkus . http . cors = true resteasy . role . based . security = true Step 2: Run the web-api-secure Microservice \u00b6 Open a third terminal and start the service on port 8081. cd $ROOT_FOLDER /web-api-secure mvn clean package quarkus:dev Setup Articles microservice \u00b6 Step 1: Configure articles-secure \u00b6 Insert your the auth-server-url URL of your Keycloak instance in application.properties file and save the file. Therefore you use the Keycloak URL you got during the setup of Keycloak on IBM Cloud. cd $ROOT_FOLDER /articles-secure/src/main/resources nano application.properties Example: // When running locally, uncomment the next line, add your Keycloak URL, must end on '/auth/realms/quarkus' quarkus . oidc . auth - server - url = https : //YOUR_URL/auth/realms/quarkus quarkus . oidc . client - id = backend - service quarkus . oidc . credentials . secret = secret quarkus . http . port = 8082 quarkus . http . cors = true resteasy . role . based . security = true Step 2: Run the articles-secure Microservice \u00b6 Open a fourth terminal and start the service on port 8081. cd $ROOT_FOLDER /articles-secure mvn clean package quarkus:dev Open the Web-App \u00b6 Step 1: Open the Web-App in your local browser \u00b6 Open the following URL in your browser: http://localhost:8080 Step 2: Log in with the test user: alice, password: alice \u00b6 Congratulations, you have successfully completed this optional hands-on lab tasks for uthentication and Authorization with Keycloak and Quarkus section of the workshop. Awesome","title":"(Optional Lab 1) Setup the web-application and Microservices locally"},{"location":"app-sec-exercise-01/#setup-the-web-application-and-microservices-locally","text":"To run these optional exercises you need to ensure you have installed the following tools on your local machine and you can run them in your terminal sessions. git 2.24.1 or higher yarn 1.22.4 or higher Node.js v14.6.0 or higher Apache Maven 3.6.3 Docker 3.0.4 or higher (running Keycloak locally) Java 9 or higher","title":"Setup the web-application and Microservices locally"},{"location":"app-sec-exercise-01/#architecture","text":"Here is the local architecture whichs shows the Web-App and the two Microservices Web-API and Articles are running on your local machine in terminal sessions. Keycloak is running on Kubernetes on IBM Cloud. The gif shows the logon to the example web frontend application. This is the simplified sequence which happens in the background: When we invoke the web frontend on ` http://localhost:8080 we will be routed to login dialog provided by the Keyloak server. After the successfully Keycloak authentication we will be redirected to the web frontend and the frontend gets an access-token. The access-token contains the needed information for the authorization at the Java microservice Web-API and the user information. The web frontend extracts and displays the username. Then the web fronted uses the access-token to invoke the Web-API Microservice endpoint to get the articles and displays the Articles.","title":"Architecture"},{"location":"app-sec-exercise-01/#youtube-video-related-to-the-workshop","text":"","title":"YouTube video related to the workshop"},{"location":"app-sec-exercise-01/#step-1-clone-the-project-to-your-local-machine","text":"git clone https://github.com/IBM/cloud-native-starter.git cd cloud-native-starter/security ROOT_FOLDER = $( pwd )","title":"Step 1: Clone the project to your local machine"},{"location":"app-sec-exercise-01/#optional-setup-keycloak-locally","text":"If you have your Keycloak running on Kubernetes you just skip to setup Web-App . In this part we will setup Keycloak locally. We will run a local Keycloak Docker container and reuse an existing realm configuration. The image below shows the relevant elements we will use later.","title":"(Optional) Setup Keycloak locally"},{"location":"app-sec-exercise-01/#step-1-start-keycloak-docker-image-local","text":"Open the first terminal session and enter following command: docker run -it -e KEYCLOAK_USER = admin -e KEYCLOAK_PASSWORD = admin -p 8282 :8080 jboss/keycloak:9.0.2 Note: We use here KEYCLOAK_USER=admin KEYCLOAK_PASSWORD=admin 8282:8080 port forwarding keycloak:9.0.2 container image","title":"Step 1: Start Keycloak Docker image local"},{"location":"app-sec-exercise-01/#step-2-import-the-existing-realm-configuration","text":"Open the Keycloak in a browser select the Administration Console Use following URL: http://localhost:8282/ Login to using the URL in your browser with user/admin and password/admin Select Add realm Choose for import Select file and open the quarkus-realm.json .","title":"Step 2: Import the existing realm configuration"},{"location":"app-sec-exercise-01/#step-3-press-view-all-users","text":"You should see following users: admin , alice , jdoe","title":"Step 3: Press view all users"},{"location":"app-sec-exercise-01/#step-4-verify-the-role-mapping","text":"","title":"Step 4: Verify the role mapping"},{"location":"app-sec-exercise-01/#setup-web-app","text":"","title":"Setup Web-App"},{"location":"app-sec-exercise-01/#step-1-configure-web-app","text":"Now insert Keycloak URL /auth in main.js (`http://localhost:8282) and save the changes. cd $ROOT_FOLDER /web-app/src nano main.js Example: if ( currentHostname . indexOf ( 'localhost' ) > - 1 ) { urls = { api : 'http://localhost:8081/' , login : 'https://YOUR_URL/auth' // insert your http or https://<KeycloakURL>/auth } store . commit ( \"setAPIAndLogin\" , urls ); }","title":"Step 1: Configure web-app"},{"location":"app-sec-exercise-01/#step-2-run-the-web-app","text":"Open the second terminal session and start the application on port 8080. cd $ROOT_FOLDER /web-app yarn install yarn serve","title":"Step 2: Run the web-app"},{"location":"app-sec-exercise-01/#setup-web-api","text":"","title":"Setup Web-Api"},{"location":"app-sec-exercise-01/#step-1-configure-web-api-secure","text":"Insert your the auth-server-url URL of your Keycloak instance in application.properties file and save the file. Therefore you use the Keycloak URL you got during the setup of Keycloak on IBM Cloud. cd $ROOT_FOLDER /web-api-secure/src/main/resources nano application.properties Example: // When running locally, uncomment the next line, add your Keycloak URL, must end on '/auth/realms/quarkus' quarkus . oidc . auth - server - url = https : //YOUR_URL/auth/realms/quarkus quarkus . oidc . client - id = backend - service quarkus . oidc . credentials . secret = secret quarkus . http . port = 8081 quarkus . http . cors = true resteasy . role . based . security = true","title":"Step 1: Configure web-api-secure"},{"location":"app-sec-exercise-01/#step-2-run-the-web-api-secure-microservice","text":"Open a third terminal and start the service on port 8081. cd $ROOT_FOLDER /web-api-secure mvn clean package quarkus:dev","title":"Step 2: Run the web-api-secure Microservice"},{"location":"app-sec-exercise-01/#setup-articles-microservice","text":"","title":"Setup Articles microservice"},{"location":"app-sec-exercise-01/#step-1-configure-articles-secure","text":"Insert your the auth-server-url URL of your Keycloak instance in application.properties file and save the file. Therefore you use the Keycloak URL you got during the setup of Keycloak on IBM Cloud. cd $ROOT_FOLDER /articles-secure/src/main/resources nano application.properties Example: // When running locally, uncomment the next line, add your Keycloak URL, must end on '/auth/realms/quarkus' quarkus . oidc . auth - server - url = https : //YOUR_URL/auth/realms/quarkus quarkus . oidc . client - id = backend - service quarkus . oidc . credentials . secret = secret quarkus . http . port = 8082 quarkus . http . cors = true resteasy . role . based . security = true","title":"Step 1: Configure articles-secure"},{"location":"app-sec-exercise-01/#step-2-run-the-articles-secure-microservice","text":"Open a fourth terminal and start the service on port 8081. cd $ROOT_FOLDER /articles-secure mvn clean package quarkus:dev","title":"Step 2: Run the articles-secure Microservice"},{"location":"app-sec-exercise-01/#open-the-web-app","text":"","title":"Open the Web-App"},{"location":"app-sec-exercise-01/#step-1-open-the-web-app-in-your-local-browser","text":"Open the following URL in your browser: http://localhost:8080","title":"Step 1: Open the Web-App in your local browser"},{"location":"app-sec-exercise-01/#step-2-log-in-with-the-test-user-alice-password-alice","text":"Congratulations, you have successfully completed this optional hands-on lab tasks for uthentication and Authorization with Keycloak and Quarkus section of the workshop. Awesome","title":"Step 2: Log in with the test user: alice, password: alice"},{"location":"app-sec-exercise-01/APPLICATION_AUTHENTICATION/","text":"Authentication in the Vue.js fronted \u00b6 There are several ways to use Keycloak from web applications. The easiest option is to use the official Keycloak JavaScript client library which is defined as dependency in package.json. The shows the simplified architecture: The Vue.js application triggers the authentication directly when the application is opened. See the file main.js: import Keycloak from 'keycloak-js' ; let initOptions = { url : 'https://keycloak-default.niklas-heidloff-b3c-4x16-162e406f043e20da9b0ef0731954a894-0000.us-south.containers.appdomain.cloud/auth' , realm : 'quarkus' , clientId : 'frontend' , onLoad : 'login-required' } Vue . config . productionTip = false Vue . config . devtools = true Vue . use ( BootstrapVue ); let keycloak = Keycloak ( initOptions ); keycloak . init ({ onLoad : initOptions . onLoad }). then (( auth ) => { if ( ! auth ) { window . location . reload (); } new Vue ({ store , router , render : h => h ( App ) }). $mount ( '#app' ) let payload = { idToken : keycloak . idToken , accessToken : keycloak . token } if ( keycloak . token && keycloak . idToken && keycloak . token != '' && keycloak . idToken != '' ) { store . commit ( \"login\" , payload ); console . log ( \"User has logged in: \" + keycloak . subject ) } else { store . commit ( \"logout\" ); } In order to use the Keycloak API, three pieces of information are required. The Keycloak URL , the realm and the client id . As you see in the image below the Vuex store saves access token , id token and user name . When the tokens expire, new tokens are requested via the refresh token und the Vuex store is updated. Related blog post","title":"Lab 2. Authentication in Vue.js fronted application"},{"location":"app-sec-exercise-01/APPLICATION_AUTHENTICATION/#authentication-in-the-vuejs-fronted","text":"There are several ways to use Keycloak from web applications. The easiest option is to use the official Keycloak JavaScript client library which is defined as dependency in package.json. The shows the simplified architecture: The Vue.js application triggers the authentication directly when the application is opened. See the file main.js: import Keycloak from 'keycloak-js' ; let initOptions = { url : 'https://keycloak-default.niklas-heidloff-b3c-4x16-162e406f043e20da9b0ef0731954a894-0000.us-south.containers.appdomain.cloud/auth' , realm : 'quarkus' , clientId : 'frontend' , onLoad : 'login-required' } Vue . config . productionTip = false Vue . config . devtools = true Vue . use ( BootstrapVue ); let keycloak = Keycloak ( initOptions ); keycloak . init ({ onLoad : initOptions . onLoad }). then (( auth ) => { if ( ! auth ) { window . location . reload (); } new Vue ({ store , router , render : h => h ( App ) }). $mount ( '#app' ) let payload = { idToken : keycloak . idToken , accessToken : keycloak . token } if ( keycloak . token && keycloak . idToken && keycloak . token != '' && keycloak . idToken != '' ) { store . commit ( \"login\" , payload ); console . log ( \"User has logged in: \" + keycloak . subject ) } else { store . commit ( \"logout\" ); } In order to use the Keycloak API, three pieces of information are required. The Keycloak URL , the realm and the client id . As you see in the image below the Vuex store saves access token , id token and user name . When the tokens expire, new tokens are requested via the refresh token und the Vuex store is updated. Related blog post","title":"Authentication in the Vue.js fronted"},{"location":"app-sec-exercise-01/APPLICATION_AUTHORIZATION/","text":"Authorization in Quarkus application \u00b6 Quarkus comes with two great quides that describe how to use Keycloak in web apps and services: Use OpenID Connect to Protect Service Applications Use OpenID Connect to Protect Web Applications Develop protected Endpoints The Microservice Articles provides an endpoint /articles which only users with the role user can access. In application.properties the Keycloak URL is defined as well as the client ID and secret. The shows the simplified architecture: Developing protected Endpoints \u00b6 The service Articles provides an endpoint \u2018/articles\u2019 which only users with the role \u2018user\u2019 can access. In application.properties the Keycloak URL is defined as well as the client ID and secret. quarkus . oidc . auth - server - url = https : //YOUR_URL/auth/realms/quarkus quarkus . oidc . client - id = backend - service quarkus . oidc . credentials . secret = secret quarkus . http . port = 8082 quarkus . http . cors = true resteasy . role . based . security = true Note the line resteasy.role.based.security=true . This setting is important, so that the Articles service can receive the Authorization header from the Web-API service. I couldn\u2019t find this in the Quarkus documentation, but Phillip Kr\u00fcger from the Quarkus team provided this information. Once you\u2019ve configured your Quarkus application, implementing the endpoint is trivial. Here we use @RolesAllowed , but there are other annotations available, for example @Authenticated . @GET @Path ( \"/articles\" ) @Produces ( MediaType . APPLICATION_JSON ) @RolesAllowed ( \"user\" ) @NoCache public Set < Article > getArticles () { return articles ; } This allows the test user Alice to invoke this endpoint, since she has the role `user. Invoking protected Endpoints \u00b6 The Web-API service has also a protected endpoint which has been implemented as above. Additionally it also invokes the Articles service. In order to do this, the MicroProfile REST Client is used. Let\u2019s take at the configuration first. quarkus . oidc . auth - server - url = https : //keycloak-default.niklas-heidloff-b3c-4x16-162e406f043e20da9b0ef0731954a894-0000.us-south.containers.appdomain.cloud/auth/realms/quarkus quarkus . oidc . client - id = backend - service quarkus . oidc . credentials . secret = secret quarkus . http . port = 8081 quarkus . http . cors = true org . eclipse . microprofile . rest . client . propagateHeaders = Authorization The last line (6) is important again. This allows forwarding the authorization header with the JWT token without having to implement any code. private ArticlesService articlesService ; @PostConstruct void initialize () { URI apiV1 = UriBuilder . fromUri ( \"http://{host}:{port}/articles\" ). build ( articlesHost , articlesPort ); articlesService = RestClientBuilder . newBuilder () . baseUri ( apiV1 ) . register ( ExceptionMapperArticles . class ) . build ( ArticlesService . class ); } public List < CoreArticle > getArticles ( int amount ) throws NoConnectivity { try { return articlesService . getArticlesFromService ( amount ); } catch ( Exception e ) { throw new NoConnectivity ( e ); } } Related blog post","title":"Lab 3. Authorization in Quarkus application"},{"location":"app-sec-exercise-01/APPLICATION_AUTHORIZATION/#authorization-in-quarkus-application","text":"Quarkus comes with two great quides that describe how to use Keycloak in web apps and services: Use OpenID Connect to Protect Service Applications Use OpenID Connect to Protect Web Applications Develop protected Endpoints The Microservice Articles provides an endpoint /articles which only users with the role user can access. In application.properties the Keycloak URL is defined as well as the client ID and secret. The shows the simplified architecture:","title":"Authorization in Quarkus application"},{"location":"app-sec-exercise-01/APPLICATION_AUTHORIZATION/#developing-protected-endpoints","text":"The service Articles provides an endpoint \u2018/articles\u2019 which only users with the role \u2018user\u2019 can access. In application.properties the Keycloak URL is defined as well as the client ID and secret. quarkus . oidc . auth - server - url = https : //YOUR_URL/auth/realms/quarkus quarkus . oidc . client - id = backend - service quarkus . oidc . credentials . secret = secret quarkus . http . port = 8082 quarkus . http . cors = true resteasy . role . based . security = true Note the line resteasy.role.based.security=true . This setting is important, so that the Articles service can receive the Authorization header from the Web-API service. I couldn\u2019t find this in the Quarkus documentation, but Phillip Kr\u00fcger from the Quarkus team provided this information. Once you\u2019ve configured your Quarkus application, implementing the endpoint is trivial. Here we use @RolesAllowed , but there are other annotations available, for example @Authenticated . @GET @Path ( \"/articles\" ) @Produces ( MediaType . APPLICATION_JSON ) @RolesAllowed ( \"user\" ) @NoCache public Set < Article > getArticles () { return articles ; } This allows the test user Alice to invoke this endpoint, since she has the role `user.","title":"Developing protected Endpoints"},{"location":"app-sec-exercise-01/APPLICATION_AUTHORIZATION/#invoking-protected-endpoints","text":"The Web-API service has also a protected endpoint which has been implemented as above. Additionally it also invokes the Articles service. In order to do this, the MicroProfile REST Client is used. Let\u2019s take at the configuration first. quarkus . oidc . auth - server - url = https : //keycloak-default.niklas-heidloff-b3c-4x16-162e406f043e20da9b0ef0731954a894-0000.us-south.containers.appdomain.cloud/auth/realms/quarkus quarkus . oidc . client - id = backend - service quarkus . oidc . credentials . secret = secret quarkus . http . port = 8081 quarkus . http . cors = true org . eclipse . microprofile . rest . client . propagateHeaders = Authorization The last line (6) is important again. This allows forwarding the authorization header with the JWT token without having to implement any code. private ArticlesService articlesService ; @PostConstruct void initialize () { URI apiV1 = UriBuilder . fromUri ( \"http://{host}:{port}/articles\" ). build ( articlesHost , articlesPort ); articlesService = RestClientBuilder . newBuilder () . baseUri ( apiV1 ) . register ( ExceptionMapperArticles . class ) . build ( ArticlesService . class ); } public List < CoreArticle > getArticles ( int amount ) throws NoConnectivity { try { return articlesService . getArticlesFromService ( amount ); } catch ( Exception e ) { throw new NoConnectivity ( e ); } } Related blog post","title":"Invoking protected Endpoints"},{"location":"p-sec-exercise-01/","text":"Deploy microservices to Kubernetes \u00b6 In this exercise we will run the application in your Kubernetes cluster using precompiled container images for our sample application: articles-secure, web-api-secure, and web-app. These container images have been uploaded to Docker Hub . When running locally, you will set the Keycloak URL as OpenID Connect (OIDC) provider in application.properties. When running on a Kubernetes cluster we cannot set the OIDC provider (keycloak) in application.properties without recompiling the code, building a new image, and loading this image in a Image repository that is accessible to your Kubernetes cluster. So for this example, we specify the Quarkus OIDC property as environment variable during deployment. The environment variable is read from a config map. STEP 1: Apply configmap \u00b6 This is our configmap definition: kind: ConfigMap apiVersion: v1 metadata: name: security-url-config data: QUARKUS_OIDC_AUTH_SERVER_URL: \"http://keycloak:8080/auth/realms/quarkus\" Our Keycloak service runs in the same namespace as the rest of the application, so all we need is the name of the service (keycloak) and the port numer (8080). Apply the configmap.yaml cd $ROOT_FOLDER /IKS kubectl apply -f configmap.yaml STEP 2: Now deploy the 3 services \u00b6 Deploy Articles Microservice cd $ROOT_FOLDER /articles-secure/deployment kubectl apply -f articles.yaml Deploy Web-API Microservice cd $ROOT_FOLDER /web-api-secure/deployment kubectl apply -f web-api.yaml Deploy Web-App Vue.js frontend application cd $ROOT_FOLDER /web-app/deployment kubectl apply -f web-app.yaml Verify all pods are running kubectl get pods Example output: NAME READY STATUS RESTARTS AGE articles-5df77c46b4-v7xcd 2 /2 Running 0 3h35m keycloak-77cffb978-vjttk 2 /2 Running 0 44h web-api-5c9698b875-kz82k 2 /2 Running 0 3h35m web-app-659c4676d9-pw6f8 2 /2 Running 0 3h34m STEP 3: Adjust the redirect, admin, web origins URLs in Keycloak \u00b6 Try to open the Cloud-Native-Starter application in a browser. Use the $INGRESSURL of your cluster, which is the URL to the frontend application Web_APP you deployed before. echo https:// $INGRESSURL You will see we need to configure the redirect in Keycloak Open Keycloak in a browser and login to Keycloak with user: admin and password: admin . Get the right URL by display the URL with the following terminal command. echo https:// $INGRESSURL /auth/admin/master/console/#/realms/quarkus Select Clients and then frontend in Keycloak. Ajust the client frontend URIs https://YOUR-URL:auth with valid redirect URI you get with the command: echo https:// $INGRESSURL Replace the entries with your value. STEP 4: Open the Cloud Native Starter application in your browser \u00b6 Use following URL: echo https:// $INGRESSURL Login in with user: alice and password: alice Now you see the entries of the articles Note: The image shows you in Kiali the running applications. These are the simplified steps you see in the image. This is not a part of your hands-on tasks. * 1: The `web-app` will be requested buy our URL to be loaded in a webbrowser. * 2: The `web-app` in the webbrowser does connect to `Keycloak` for Authentication. * 2: The `web-app` in the webbrowser does connect to the `web-api` to get the Articles information. * 4: The `web-api` in does validated the authorization with `Keyloak`. * 5: The `web-api` in the webbrowser does connect to the `articles` to get the Articles information. * 6: The `articles` in does validated the authorization with `Keyloak`.","title":"Lab 1. Deploy microservices to Kubernetes"},{"location":"p-sec-exercise-01/#deploy-microservices-to-kubernetes","text":"In this exercise we will run the application in your Kubernetes cluster using precompiled container images for our sample application: articles-secure, web-api-secure, and web-app. These container images have been uploaded to Docker Hub . When running locally, you will set the Keycloak URL as OpenID Connect (OIDC) provider in application.properties. When running on a Kubernetes cluster we cannot set the OIDC provider (keycloak) in application.properties without recompiling the code, building a new image, and loading this image in a Image repository that is accessible to your Kubernetes cluster. So for this example, we specify the Quarkus OIDC property as environment variable during deployment. The environment variable is read from a config map.","title":"Deploy microservices to Kubernetes"},{"location":"p-sec-exercise-01/#step-1-apply-configmap","text":"This is our configmap definition: kind: ConfigMap apiVersion: v1 metadata: name: security-url-config data: QUARKUS_OIDC_AUTH_SERVER_URL: \"http://keycloak:8080/auth/realms/quarkus\" Our Keycloak service runs in the same namespace as the rest of the application, so all we need is the name of the service (keycloak) and the port numer (8080). Apply the configmap.yaml cd $ROOT_FOLDER /IKS kubectl apply -f configmap.yaml","title":"STEP 1: Apply configmap"},{"location":"p-sec-exercise-01/#step-2-now-deploy-the-3-services","text":"Deploy Articles Microservice cd $ROOT_FOLDER /articles-secure/deployment kubectl apply -f articles.yaml Deploy Web-API Microservice cd $ROOT_FOLDER /web-api-secure/deployment kubectl apply -f web-api.yaml Deploy Web-App Vue.js frontend application cd $ROOT_FOLDER /web-app/deployment kubectl apply -f web-app.yaml Verify all pods are running kubectl get pods Example output: NAME READY STATUS RESTARTS AGE articles-5df77c46b4-v7xcd 2 /2 Running 0 3h35m keycloak-77cffb978-vjttk 2 /2 Running 0 44h web-api-5c9698b875-kz82k 2 /2 Running 0 3h35m web-app-659c4676d9-pw6f8 2 /2 Running 0 3h34m","title":"STEP 2: Now deploy the 3 services"},{"location":"p-sec-exercise-01/#step-3-adjust-the-redirect-admin-web-origins-urls-in-keycloak","text":"Try to open the Cloud-Native-Starter application in a browser. Use the $INGRESSURL of your cluster, which is the URL to the frontend application Web_APP you deployed before. echo https:// $INGRESSURL You will see we need to configure the redirect in Keycloak Open Keycloak in a browser and login to Keycloak with user: admin and password: admin . Get the right URL by display the URL with the following terminal command. echo https:// $INGRESSURL /auth/admin/master/console/#/realms/quarkus Select Clients and then frontend in Keycloak. Ajust the client frontend URIs https://YOUR-URL:auth with valid redirect URI you get with the command: echo https:// $INGRESSURL Replace the entries with your value.","title":"STEP 3: Adjust the redirect, admin, web origins URLs in Keycloak"},{"location":"p-sec-exercise-01/#step-4-open-the-cloud-native-starter-application-in-your-browser","text":"Use following URL: echo https:// $INGRESSURL Login in with user: alice and password: alice Now you see the entries of the articles Note: The image shows you in Kiali the running applications. These are the simplified steps you see in the image. This is not a part of your hands-on tasks. * 1: The `web-app` will be requested buy our URL to be loaded in a webbrowser. * 2: The `web-app` in the webbrowser does connect to `Keycloak` for Authentication. * 2: The `web-app` in the webbrowser does connect to the `web-api` to get the Articles information. * 4: The `web-api` in does validated the authorization with `Keyloak`. * 5: The `web-api` in the webbrowser does connect to the `articles` to get the Articles information. * 6: The `articles` in does validated the authorization with `Keyloak`.","title":"STEP 4: Open the Cloud Native Starter application in your browser"},{"location":"p-sec-exercise-02/","text":"Secure microservices with strict mTLS \u00b6 Istio uses Mutual authentication with Transport Layer Security (mTLS) to secure the communication between microservices without requiring application code changes. Security is provided by authenticating and encrypting communication paths within the cluster. This is becoming a common security and compliance requirement. Delegating communication security to Istio (as opposed to implementing TLS in each microservice) ensures that your application will be deployed with consistent and manageable security policies. This exercise will cover only a part of the Istio security features. The Istio documentation has a lot more information. Istio provides each Envoy sidecar proxy with a strong (cryptographic) identity, in the form of a certificate created by Istios own Certificate Authority (CA). This identity is based on the microservice's service account and is independent of its specific network location, such as cluster or current IP address. This is called Secure naming. Envoys then use the certificates to identify each other and establish an authenticated and encrypted communication channel between them. Istio is responsible for: Providing each service with an identity representing its role. Providing a common trust root to allow Envoys to validate and authenticate each other. Providing a key management system, automating generation, distribution, and rotation of certificates and keys. When an application microservice connects to another microservice, the communication is redirected through the client side and server side Envoys. The end-to-end communication path is: Local TCP connection (i.e., localhost, not reaching the \"wire\") between the application and Envoy (client- and server-side); Mutually authenticated and encrypted connection between Envoy proxies. This includes the Istio Ingress for incoming (and the Istio Egress for outgoing) connections. Your Kubernetes cluster may/will have its own ingress but this ingress is not paired with an Envoy sidecar and therefore is not able to directly participate in secure and encrypted communications. mTLS is enabled by default for the communication between Envoys but it is enabled in permissive mode . This means that a microservice outside of the Istio Service Mesh, one without a Envoy proxy, can communicate with a microservice within the Service Mesh. This allows you to bring your microservices into the Service Mesh and then gradually turn on and test security. TASK 1: Test permissive mode \u00b6 In this task we access the Web-API service using the services nodeport, the IP address of a worker node, and unencrypted HTTP, effectively bypassing the Istio Ingress This is only possible because Istio is still using mTLS in permissive mode. Step 1: Create a access-token \u00b6 We need a JSON Web Token (JWT) to access the service: export access_token = $( curl -d \"username=alice\" -d \"password=alice\" -d \"grant_type=password\" -d \"client_id=frontend\" https:// $INGRESSURL /auth/realms/quarkus/protocol/openid-connect/token | sed -n 's|.*\"access_token\":\"\\([^\"]*\\)\".*|\\1|p' ) echo $access_token Note: REMEMBER that an access-token is only valid for 60 seconds ;-). You need to be quick with the next steps otherwise the token will already be involid! Step 2: Get the NodePort of the Web-API Microservice \u00b6 export nodeport = $( kubectl get svc web-api --ignore-not-found --output 'jsonpath={.spec.ports[*].nodePort}' ) echo $nodeport Step 3: Get a external Worker IP address of the Web-API Microservice \u00b6 export workerip = $( ibmcloud ks workers --cluster $MYCLUSTER | awk '/Ready/ {print $2;exit;}' ) echo $workerip We now have an external IP address and port to access the Web-API service. Step 4: Use no TLS just HTTP to get the articles from the Web-API Microservice \u00b6 curl -i http:// $workerip : $nodeport /articles -H \"Authorization: Bearer $access_token \" Example output: HTTP/1.1 200 OK cache-control: no-cache content-length: 1663 content-type: application/json x-envoy-upstream-service-time: 60 x-envoy-peer-metadata: CjgKDElOU1RBTkNF*****kaB3dlYi1hcGk = x-envoy-peer-metadata-id: sidecar~172.30.83.82~web-api-5c9698b875-sn9ck.default~default.svc.cluster.local date: Wed, 05 Aug 2020 14 :15:57 GMT server: istio-envoy x-envoy-decorator-operation: web-api.default.svc.cluster.local:8081/* [{ \"authorBlog\" : \"\" , \"authorTwitter\" : \"\" , \"title\" : \"Blue Cloud Mirror \u2014 (Don\u2019t) Open The Doors!\" , \"url\" : \"https://haralduebele.blog/2019/02/17/blue-cloud-mirror-dont-open-the-doors/\" } , { \"authorBlog\" : \"\" , \"authorTwitter\" : \"\" , \"title\" : \"Recent Java Updates from IBM\" , \"url\" : \"http://heidloff.net/article/recent-java-updates-from-ibm\" } ,******* \"title\" : \"Three awesome TensorFlow.js Models for Visual Recognition\" , \"url\" : \"http://heidloff.net/article/tensorflowjs-visual-recognition\" } , { \"authorBlog\" : \"\" , \"authorTwitter\" : \"\" ] As result of the last command you can see an HTTP status of 200 which means OK and the correct result, a list of blog articles as a JSON object. This is not totally unsecure since we needed an access token (JWT) to make the REST call but we were able to access the service using http only on port 80. Somebody with access to the cluster and the required skills could stage a man-in-the-middle attack and read the data because it is not encrypted. We are going to change this in the next step. TASK 2: Set mTLS to strict in default namespace and for services \u00b6 By switching mTLS to strict mode it is impossible for external traffic to bypass the Istio Ingress. External traffic means external to the Kubernetes cluster (coming from the outside) or external to the default namespace, i.e. not being part of the servie mesh. This is the reason why we installed Keycloak into the default namespace: that way it is part of our service mesh and included in the mTLS \"dance\" automatically. In a real world example you would most likely use a different approach. Step 1: The following command creates a PeerAuthentication policy for the default namespace \u00b6 cd $ROOT_FOLDER /IKS kubectl apply -f mtls.yaml This enforces mTLS in the default namespace. So simple! Step 2: Create a new access-token and invoke the Web-API Microservice with HTTP again \u00b6 As you will see, you can no longer access the service, even if you know its NodePort and the external IP of a Kubernetess worker node. Create access-token export access_token = $( curl -d \"username=alice\" -d \"password=alice\" -d \"grant_type=password\" -d \"client_id=frontend\" https:// $INGRESSURL /auth/realms/quarkus/protocol/openid-connect/token | sed -n 's|.*\"access_token\":\"\\([^\"]*\\)\".*|\\1|p' ) echo $access_token Invoke Web-API Microservice curl -i http:// $workerip : $nodeport /articles -H \"Authorization: Bearer $access_token \" Example output: curl: ( 56 ) Recv failure: Connection reset by peer Now everything is secure. If you check the Cloud Native Starter frontend in the browser, nothing should have changed because it already used enrypted paths: Access to the Web-App (service) is through the Istio Ingress gateway using https (loading the JavaScript/Vue.js code into the browser) The (external) Web-App in the browser is accessing the Keycloak server and the Web-API service using https Those requests come in through the Istio Ingress gateway Since the Istio Ingress gateway , Keycloak , and Web-API are all part of the service mesh, communication between them is already encrypted using mTLS REST API calls from Web-API to Articles and from Web-API or Articles to Keycloak use mTLS Access from outside into the applications/services running in the default namespace is prohibited now by enforcing strict mTLS . You can only access the services through the Istio Ingress. This is the result of your work so far: Note: The image shows you in Kiali mTLS is enabled on the http connections. This is not a part of your hands-on tasks. Congratulations, you have successfully completed this lab and reached the end of the Platform security with mTLS section of the workshop. Awesome","title":"Lab 2. Secure microservices using Authentication with mTLS"},{"location":"p-sec-exercise-02/#secure-microservices-with-strict-mtls","text":"Istio uses Mutual authentication with Transport Layer Security (mTLS) to secure the communication between microservices without requiring application code changes. Security is provided by authenticating and encrypting communication paths within the cluster. This is becoming a common security and compliance requirement. Delegating communication security to Istio (as opposed to implementing TLS in each microservice) ensures that your application will be deployed with consistent and manageable security policies. This exercise will cover only a part of the Istio security features. The Istio documentation has a lot more information. Istio provides each Envoy sidecar proxy with a strong (cryptographic) identity, in the form of a certificate created by Istios own Certificate Authority (CA). This identity is based on the microservice's service account and is independent of its specific network location, such as cluster or current IP address. This is called Secure naming. Envoys then use the certificates to identify each other and establish an authenticated and encrypted communication channel between them. Istio is responsible for: Providing each service with an identity representing its role. Providing a common trust root to allow Envoys to validate and authenticate each other. Providing a key management system, automating generation, distribution, and rotation of certificates and keys. When an application microservice connects to another microservice, the communication is redirected through the client side and server side Envoys. The end-to-end communication path is: Local TCP connection (i.e., localhost, not reaching the \"wire\") between the application and Envoy (client- and server-side); Mutually authenticated and encrypted connection between Envoy proxies. This includes the Istio Ingress for incoming (and the Istio Egress for outgoing) connections. Your Kubernetes cluster may/will have its own ingress but this ingress is not paired with an Envoy sidecar and therefore is not able to directly participate in secure and encrypted communications. mTLS is enabled by default for the communication between Envoys but it is enabled in permissive mode . This means that a microservice outside of the Istio Service Mesh, one without a Envoy proxy, can communicate with a microservice within the Service Mesh. This allows you to bring your microservices into the Service Mesh and then gradually turn on and test security.","title":"Secure microservices with strict mTLS"},{"location":"p-sec-exercise-02/#task-1-test-permissive-mode","text":"In this task we access the Web-API service using the services nodeport, the IP address of a worker node, and unencrypted HTTP, effectively bypassing the Istio Ingress This is only possible because Istio is still using mTLS in permissive mode.","title":"TASK 1: Test permissive mode"},{"location":"p-sec-exercise-02/#step-1-create-a-access-token","text":"We need a JSON Web Token (JWT) to access the service: export access_token = $( curl -d \"username=alice\" -d \"password=alice\" -d \"grant_type=password\" -d \"client_id=frontend\" https:// $INGRESSURL /auth/realms/quarkus/protocol/openid-connect/token | sed -n 's|.*\"access_token\":\"\\([^\"]*\\)\".*|\\1|p' ) echo $access_token Note: REMEMBER that an access-token is only valid for 60 seconds ;-). You need to be quick with the next steps otherwise the token will already be involid!","title":"Step 1: Create a access-token"},{"location":"p-sec-exercise-02/#step-2-get-the-nodeport-of-the-web-api-microservice","text":"export nodeport = $( kubectl get svc web-api --ignore-not-found --output 'jsonpath={.spec.ports[*].nodePort}' ) echo $nodeport","title":"Step 2: Get the NodePort of the Web-API Microservice"},{"location":"p-sec-exercise-02/#step-3-get-a-external-worker-ip-address-of-the-web-api-microservice","text":"export workerip = $( ibmcloud ks workers --cluster $MYCLUSTER | awk '/Ready/ {print $2;exit;}' ) echo $workerip We now have an external IP address and port to access the Web-API service.","title":"Step 3: Get a external Worker IP address of the Web-API Microservice"},{"location":"p-sec-exercise-02/#step-4-use-no-tls-just-http-to-get-the-articles-from-the-web-api-microservice","text":"curl -i http:// $workerip : $nodeport /articles -H \"Authorization: Bearer $access_token \" Example output: HTTP/1.1 200 OK cache-control: no-cache content-length: 1663 content-type: application/json x-envoy-upstream-service-time: 60 x-envoy-peer-metadata: CjgKDElOU1RBTkNF*****kaB3dlYi1hcGk = x-envoy-peer-metadata-id: sidecar~172.30.83.82~web-api-5c9698b875-sn9ck.default~default.svc.cluster.local date: Wed, 05 Aug 2020 14 :15:57 GMT server: istio-envoy x-envoy-decorator-operation: web-api.default.svc.cluster.local:8081/* [{ \"authorBlog\" : \"\" , \"authorTwitter\" : \"\" , \"title\" : \"Blue Cloud Mirror \u2014 (Don\u2019t) Open The Doors!\" , \"url\" : \"https://haralduebele.blog/2019/02/17/blue-cloud-mirror-dont-open-the-doors/\" } , { \"authorBlog\" : \"\" , \"authorTwitter\" : \"\" , \"title\" : \"Recent Java Updates from IBM\" , \"url\" : \"http://heidloff.net/article/recent-java-updates-from-ibm\" } ,******* \"title\" : \"Three awesome TensorFlow.js Models for Visual Recognition\" , \"url\" : \"http://heidloff.net/article/tensorflowjs-visual-recognition\" } , { \"authorBlog\" : \"\" , \"authorTwitter\" : \"\" ] As result of the last command you can see an HTTP status of 200 which means OK and the correct result, a list of blog articles as a JSON object. This is not totally unsecure since we needed an access token (JWT) to make the REST call but we were able to access the service using http only on port 80. Somebody with access to the cluster and the required skills could stage a man-in-the-middle attack and read the data because it is not encrypted. We are going to change this in the next step.","title":"Step 4: Use no TLS just HTTP to get the articles from the Web-API Microservice"},{"location":"p-sec-exercise-02/#task-2-set-mtls-to-strict-in-default-namespace-and-for-services","text":"By switching mTLS to strict mode it is impossible for external traffic to bypass the Istio Ingress. External traffic means external to the Kubernetes cluster (coming from the outside) or external to the default namespace, i.e. not being part of the servie mesh. This is the reason why we installed Keycloak into the default namespace: that way it is part of our service mesh and included in the mTLS \"dance\" automatically. In a real world example you would most likely use a different approach.","title":"TASK 2: Set mTLS to strict in default namespace and for services"},{"location":"p-sec-exercise-02/#step-1-the-following-command-creates-a-peerauthentication-policy-for-the-default-namespace","text":"cd $ROOT_FOLDER /IKS kubectl apply -f mtls.yaml This enforces mTLS in the default namespace. So simple!","title":"Step 1: The following command creates a PeerAuthentication policy for the default namespace"},{"location":"p-sec-exercise-02/#step-2-create-a-new-access-token-and-invoke-the-web-api-microservice-with-http-again","text":"As you will see, you can no longer access the service, even if you know its NodePort and the external IP of a Kubernetess worker node. Create access-token export access_token = $( curl -d \"username=alice\" -d \"password=alice\" -d \"grant_type=password\" -d \"client_id=frontend\" https:// $INGRESSURL /auth/realms/quarkus/protocol/openid-connect/token | sed -n 's|.*\"access_token\":\"\\([^\"]*\\)\".*|\\1|p' ) echo $access_token Invoke Web-API Microservice curl -i http:// $workerip : $nodeport /articles -H \"Authorization: Bearer $access_token \" Example output: curl: ( 56 ) Recv failure: Connection reset by peer Now everything is secure. If you check the Cloud Native Starter frontend in the browser, nothing should have changed because it already used enrypted paths: Access to the Web-App (service) is through the Istio Ingress gateway using https (loading the JavaScript/Vue.js code into the browser) The (external) Web-App in the browser is accessing the Keycloak server and the Web-API service using https Those requests come in through the Istio Ingress gateway Since the Istio Ingress gateway , Keycloak , and Web-API are all part of the service mesh, communication between them is already encrypted using mTLS REST API calls from Web-API to Articles and from Web-API or Articles to Keycloak use mTLS Access from outside into the applications/services running in the default namespace is prohibited now by enforcing strict mTLS . You can only access the services through the Istio Ingress. This is the result of your work so far: Note: The image shows you in Kiali mTLS is enabled on the http connections. This is not a part of your hands-on tasks. Congratulations, you have successfully completed this lab and reached the end of the Platform security with mTLS section of the workshop. Awesome","title":"Step 2: Create a new access-token and invoke the Web-API Microservice with HTTP again"},{"location":"p-sec-exercise-03/","text":"Istio Authorization \u00b6 This is an optional lab, run through it if time permits. Besides authentication using mTLS, Istio can also provide authorization services: End-user to workload Workload to workload The end-user to workload authentication we handle in our example in the application code itself, you will learn about it in the last section of our workshop (Application security with Keycloak and Quarkus). In this exercise we will learn how to apply authorization policies to further secure communication within the service mesh, workload to workload. In our example we will use Kubernetes Service Accounts to perform the authorization. Review the existing deployment \u00b6 When you create a pod, if you do not specify a service account, it is automatically assigned the default service account in the same namespace. You can check this for the articles service: STEP 1: Get the full name of the articles pod from the resulting list: \u00b6 kubectl get pods Example output: NAME READY STATUS RESTARTS AGE articles-xxxxxxxxxx-yyyyy 2 /2 Running 0 3d23h keycloak-77cffb978-nbmjj 2 /2 Running 0 3d23h web-api-5c9698b875-c8vrt 2 /2 Running 0 3d23h web-app-79499c4b99-dv2hs 2 /2 Running 0 3d23h STEP 2: Now display the details for the pod in YAML format and search for the term serviceAccount : \u00b6 kubectl get pod articles-xxxxxxxxxx-yyyyy -o json | grep serviceAccount Result: \"serviceAccount\" : \"default\" , \"serviceAccountName\" : \"default\" , The articles pod indeed uses the default service account. Modify deployments to use service accounts \u00b6 Step 1: First we create 2 service accounts (sa) for our 2 services \u00b6 kubectl create sa articles kubectl create sa web-api Note: The image shows you in the Kubernetes Dashboard the two new service accounts. This is not a part of your hands-on tasks. Step 2: Then we replace the deployment descriptions to use the service accounts we just created: \u00b6 kubectl replace -f $ROOT_FOLDER /articles-secure/deployment/articles-sa.yaml kubectl replace -f $ROOT_FOLDER /web-api-secure/deployment/web-api-sa.yaml Step 3: This will recreate the articles and web-api pods. Check with: \u00b6 kubectl get pods kubectl get pod articles-xxxxxxxxxx-yyyyy -o json | grep serviceAccount Result: \"serviceAccount\" : \"articles\" , \"serviceAccountName\" : \"articles\" If you test the application in the browser it should work exactly the same as before. Authorization Policy \u00b6 Step 1: Verify the authorization policy \u00b6 First we apply an incomplete authorization policy to the articles service. It looks like this: apiVersion : security.istio.io/v1beta1 kind : AuthorizationPolicy metadata : name : articlesaccess spec : selector : matchLabels : app : articles action : ALLOW Istio documentation specifies: If any allow policies are applied to a workload, access to that workload is denied by default, unless explicitly allowed by the rule in the policy. We have an \"ALLOW\" policy but no rule is specified which makes it effectively a \"DENY ALL\" rule. Step 2: Apply with rule \u00b6 kubectl apply -f $ROOT_FOLDER /IKS/authorization.yaml Step 3: Check the application in the browser again. It may take a while for the policy to propagate to the Envoy but eventually you will see this error in the browser: \u00b6 Example output: Articles could not be read Error: Request failed with status code 500 Step 4: Verify AuthorizationPolicy \u00b6 Now we use a correct authorization poliy. It looks like this: apiVersion : security.istio.io/v1beta1 kind : AuthorizationPolicy metadata : name : articlesaccess spec : selector : matchLabels : app : articles action : ALLOW rules : - from : - source : principals : [ \"cluster.local/ns/default/sa/web-api\" ] to : - operation : methods : [ \"GET\" , \"POST\" ] It allows GET and POST access to the articles service for the service account (sa) web-api in namespace (ns) default . Step 5: Apply rule \u00b6 Apply with: kubectl apply -f $ROOT_FOLDER /IKS/authorization-w-rule.yaml Step 5: Verify the access \u00b6 Check the application in the browser again. It may take a while for the policy to propagate to the Envoy but eventually you will see that the application works. Now we using Istio and Keycloak at the same time. Note: The image shows you in Kiali there is AuthorizationPolicy defined This is not a part of your hands-on tasks. Optional: Setup telemetry to inspect dependencies of the Microservices in Kiali \u00b6 \"Kiali is an observability console for Istio with service mesh configuration capabilities. It helps you to understand the structure of your service mesh by inferring the topology, and also provides the health of your mesh.\" Execute following script to setup telemetry cd $ROOT_FOLDER /IKS bash istio-setup-telemetry.sh Open a second IBM Cloud Shell terminal session Execute the port-forward command in the new terminal session: kubectl port-forward svc/kiali 3000:20001 -n istio-system Result should indicate forwarding from port 3000 to port 20001. Click on the \"Eye\" icon in the upper right corner of Cloud Shell and select port 3000. This will open a new browser tab with the Kiali dashboard. Log in with admin/admin . Open the Graph tab, in Namespaces select all namespaces and in display ensure you have selected security` This graph shows the components of your microservices architecture. Explore the other tabs. Congratulations, you have successfully completed this optional lab and you did the extra mile for Platform security with mTLS section of the workshop. Awesome","title":"(Optional Lab 3) Authorization with Istio"},{"location":"p-sec-exercise-03/#istio-authorization","text":"This is an optional lab, run through it if time permits. Besides authentication using mTLS, Istio can also provide authorization services: End-user to workload Workload to workload The end-user to workload authentication we handle in our example in the application code itself, you will learn about it in the last section of our workshop (Application security with Keycloak and Quarkus). In this exercise we will learn how to apply authorization policies to further secure communication within the service mesh, workload to workload. In our example we will use Kubernetes Service Accounts to perform the authorization.","title":"Istio Authorization"},{"location":"p-sec-exercise-03/#review-the-existing-deployment","text":"When you create a pod, if you do not specify a service account, it is automatically assigned the default service account in the same namespace. You can check this for the articles service:","title":"Review the existing deployment"},{"location":"p-sec-exercise-03/#step-1-get-the-full-name-of-the-articles-pod-from-the-resulting-list","text":"kubectl get pods Example output: NAME READY STATUS RESTARTS AGE articles-xxxxxxxxxx-yyyyy 2 /2 Running 0 3d23h keycloak-77cffb978-nbmjj 2 /2 Running 0 3d23h web-api-5c9698b875-c8vrt 2 /2 Running 0 3d23h web-app-79499c4b99-dv2hs 2 /2 Running 0 3d23h","title":"STEP 1:  Get the full name of the articles pod from the resulting list:"},{"location":"p-sec-exercise-03/#step-2-now-display-the-details-for-the-pod-in-yaml-format-and-search-for-the-term-serviceaccount","text":"kubectl get pod articles-xxxxxxxxxx-yyyyy -o json | grep serviceAccount Result: \"serviceAccount\" : \"default\" , \"serviceAccountName\" : \"default\" , The articles pod indeed uses the default service account.","title":"STEP 2: Now display the details for the pod in YAML format and search for the term serviceAccount:"},{"location":"p-sec-exercise-03/#modify-deployments-to-use-service-accounts","text":"","title":"Modify deployments to use service accounts"},{"location":"p-sec-exercise-03/#step-1-first-we-create-2-service-accounts-sa-for-our-2-services","text":"kubectl create sa articles kubectl create sa web-api Note: The image shows you in the Kubernetes Dashboard the two new service accounts. This is not a part of your hands-on tasks.","title":"Step 1: First we create 2 service accounts (sa) for our 2 services"},{"location":"p-sec-exercise-03/#step-2-then-we-replace-the-deployment-descriptions-to-use-the-service-accounts-we-just-created","text":"kubectl replace -f $ROOT_FOLDER /articles-secure/deployment/articles-sa.yaml kubectl replace -f $ROOT_FOLDER /web-api-secure/deployment/web-api-sa.yaml","title":"Step 2: Then we replace the deployment descriptions to use the service accounts we just created:"},{"location":"p-sec-exercise-03/#step-3-this-will-recreate-the-articles-and-web-api-pods-check-with","text":"kubectl get pods kubectl get pod articles-xxxxxxxxxx-yyyyy -o json | grep serviceAccount Result: \"serviceAccount\" : \"articles\" , \"serviceAccountName\" : \"articles\" If you test the application in the browser it should work exactly the same as before.","title":"Step 3: This will recreate the articles and web-api pods. Check with:"},{"location":"p-sec-exercise-03/#authorization-policy","text":"","title":"Authorization Policy"},{"location":"p-sec-exercise-03/#step-1-verify-the-authorization-policy","text":"First we apply an incomplete authorization policy to the articles service. It looks like this: apiVersion : security.istio.io/v1beta1 kind : AuthorizationPolicy metadata : name : articlesaccess spec : selector : matchLabels : app : articles action : ALLOW Istio documentation specifies: If any allow policies are applied to a workload, access to that workload is denied by default, unless explicitly allowed by the rule in the policy. We have an \"ALLOW\" policy but no rule is specified which makes it effectively a \"DENY ALL\" rule.","title":"Step 1: Verify the authorization policy"},{"location":"p-sec-exercise-03/#step-2-apply-with-rule","text":"kubectl apply -f $ROOT_FOLDER /IKS/authorization.yaml","title":"Step 2: Apply with rule"},{"location":"p-sec-exercise-03/#step-3-check-the-application-in-the-browser-again-it-may-take-a-while-for-the-policy-to-propagate-to-the-envoy-but-eventually-you-will-see-this-error-in-the-browser","text":"Example output: Articles could not be read Error: Request failed with status code 500","title":"Step 3: Check the application in the browser again. It may take a while for the policy to propagate to the Envoy but eventually you will see this error in the browser:"},{"location":"p-sec-exercise-03/#step-4-verify-authorizationpolicy","text":"Now we use a correct authorization poliy. It looks like this: apiVersion : security.istio.io/v1beta1 kind : AuthorizationPolicy metadata : name : articlesaccess spec : selector : matchLabels : app : articles action : ALLOW rules : - from : - source : principals : [ \"cluster.local/ns/default/sa/web-api\" ] to : - operation : methods : [ \"GET\" , \"POST\" ] It allows GET and POST access to the articles service for the service account (sa) web-api in namespace (ns) default .","title":"Step 4: Verify AuthorizationPolicy"},{"location":"p-sec-exercise-03/#step-5-apply-rule","text":"Apply with: kubectl apply -f $ROOT_FOLDER /IKS/authorization-w-rule.yaml","title":"Step 5: Apply rule"},{"location":"p-sec-exercise-03/#step-5-verify-the-access","text":"Check the application in the browser again. It may take a while for the policy to propagate to the Envoy but eventually you will see that the application works. Now we using Istio and Keycloak at the same time. Note: The image shows you in Kiali there is AuthorizationPolicy defined This is not a part of your hands-on tasks.","title":"Step 5: Verify the access"},{"location":"p-sec-exercise-03/#optional-setup-telemetry-to-inspect-dependencies-of-the-microservices-in-kiali","text":"\"Kiali is an observability console for Istio with service mesh configuration capabilities. It helps you to understand the structure of your service mesh by inferring the topology, and also provides the health of your mesh.\" Execute following script to setup telemetry cd $ROOT_FOLDER /IKS bash istio-setup-telemetry.sh Open a second IBM Cloud Shell terminal session Execute the port-forward command in the new terminal session: kubectl port-forward svc/kiali 3000:20001 -n istio-system Result should indicate forwarding from port 3000 to port 20001. Click on the \"Eye\" icon in the upper right corner of Cloud Shell and select port 3000. This will open a new browser tab with the Kiali dashboard. Log in with admin/admin . Open the Graph tab, in Namespaces select all namespaces and in display ensure you have selected security` This graph shows the components of your microservices architecture. Explore the other tabs. Congratulations, you have successfully completed this optional lab and you did the extra mile for Platform security with mTLS section of the workshop. Awesome","title":"Optional: Setup telemetry to inspect dependencies of the Microservices in Kiali"},{"location":"pre-work/","text":"Overview: Create your Cloud Environment \u00b6 In this workshop you will use a pre-provisioned Kubernetes cluster based on IBM Cloud Kubernetes Service (IKS) and the IBM Cloud Shell as your work environment.","title":"Overview"},{"location":"pre-work/#overview-create-your-cloud-environment","text":"In this workshop you will use a pre-provisioned Kubernetes cluster based on IBM Cloud Kubernetes Service (IKS) and the IBM Cloud Shell as your work environment.","title":"Overview: Create your Cloud Environment"},{"location":"pre-work/CLOUD_ACCOUNT/","text":"Access the Cluster \u00b6 In this section you will login to your own IBM Cloud account and then get access to an IBM Cloud Lab account which contains pre-provisioned clusters. Each workshop attendee will be granted access to one pre-provisioned cluster. Step 1: Setting up your IBM Cloud ID \u00b6 Log into IBM Cloud with an existing account: https://cloud.ibm.com OR Create your own: http://ibm.biz/nheidloff Step 2: Accessing the Cluster \u00b6 Instructors will provide a URL to a web app. Enter your IBMid (the email you used to sign up) and the workshop key (also provided by the instructor link ). Follow the instructions on the next page. You will be added to the IBM Workshop account and granted access to a cluster. Note the name of your cluster. In the example below, it's TorontoMulticlientWorkshop31 . Back in IBM Cloud, refresh the IBM Cloud Dashboard . If required, switch to the 1840867-IBM account by clicking on the account selection drop down in the top nav bar. Click on Clusters in the Resource Summary tile. Under Clusters , click on the cluster that has been assigned to you. Launch the Kubernetes Dashboard and have a look around! You can come back to this dashboard throughout your workshop. Go back to the open browser tab the open Kubernetes Cluster in the IBM Cloud web console. Now select Actions->Connect via CLI on the right-hand side. In the new window you see all steps to access your Kubernetes Cluster in a terminal session. You can easily copy and paste the commands. We will use these commands later to access the Kubernetes cluster in the IBM Cloud Shell.","title":"Access the Cluster"},{"location":"pre-work/CLOUD_ACCOUNT/#access-the-cluster","text":"In this section you will login to your own IBM Cloud account and then get access to an IBM Cloud Lab account which contains pre-provisioned clusters. Each workshop attendee will be granted access to one pre-provisioned cluster.","title":"Access the Cluster"},{"location":"pre-work/CLOUD_ACCOUNT/#step-1-setting-up-your-ibm-cloud-id","text":"Log into IBM Cloud with an existing account: https://cloud.ibm.com OR Create your own: http://ibm.biz/nheidloff","title":"Step 1: Setting up your IBM Cloud ID"},{"location":"pre-work/CLOUD_ACCOUNT/#step-2-accessing-the-cluster","text":"Instructors will provide a URL to a web app. Enter your IBMid (the email you used to sign up) and the workshop key (also provided by the instructor link ). Follow the instructions on the next page. You will be added to the IBM Workshop account and granted access to a cluster. Note the name of your cluster. In the example below, it's TorontoMulticlientWorkshop31 . Back in IBM Cloud, refresh the IBM Cloud Dashboard . If required, switch to the 1840867-IBM account by clicking on the account selection drop down in the top nav bar. Click on Clusters in the Resource Summary tile. Under Clusters , click on the cluster that has been assigned to you. Launch the Kubernetes Dashboard and have a look around! You can come back to this dashboard throughout your workshop. Go back to the open browser tab the open Kubernetes Cluster in the IBM Cloud web console. Now select Actions->Connect via CLI on the right-hand side. In the new window you see all steps to access your Kubernetes Cluster in a terminal session. You can easily copy and paste the commands. We will use these commands later to access the Kubernetes cluster in the IBM Cloud Shell.","title":"Step 2: Accessing the Cluster"},{"location":"pre-work/CLOUD_SHELL/","text":"IBM Cloud Shell \u00b6 For this workshop we'll be using the IBM Cloud Shell as work environment. The IBM Cloud Shell is a cloud-based shell that you can access through your browser. It is preconfigured with the full IBM Cloud CLI and other 3 rd party CLIs like OpenShift's oc , Helm's helm , Kubernetes' kubectl , etc. You can find the list of installed plug-ins here . Step 1: Setup the IBM Cloud Shell terminal session \u00b6 When using the IBM Cloud Shell, no client side setup is required for this workshop, it comes with all necessary CLIs (command line tools). In your browser, login to the IBM Cloud Dashboard. Make sure you select your own account in the account list at the top, then click on the IBM Cloud Shell icon. This opens a new browser tab with your IBM Cloud Shell session. Note: Your workspace includes 500 MB of temporary storage. This session will close after an hour of inactivity. If you don't have any active sessions for an hour or you reach the 50-hour weekly usage limit, your workspace data is removed. You should see you personal ID as Current account: [User]'s Account' : If you want to perform this workshop locally on your own workstation, you need a local terminal and the following tools: git curl kubectl yarn mvn Node.js Java 9 or higher Step 2: Get the Code \u00b6 In the IBM Cloud Shell execute the following command: git clone https://github.com/IBM/cloud-native-starter.git cd cloud-native-starter/security ROOT_FOLDER = $( pwd ) echo $ROOT_FOLDER Step 3. Get Access to Kubernetes \u00b6 Open provided Kubernetes cluster again in your browser tab, with the IBM Cloud web console. Switch from your own account to the provided IBM account . Switch back to the 1840867-IBM account by clicking on the account selection drop down in the top navigation bar. Click on your cluster. Now select Access on the left-hand side, here you see all steps to access your Kubernetes Cluster in a terminal session. You can easily copy and paste the given commands. Go back to the open browser tab the open Kubernetes Cluster in the IBM Cloud web console. Now select Actions->Connect via CLI on the right-hand side. Now copy and paste all these commands in sequence in your open IBM Cloud Shell terminal session. Browser tab - IBM Cloud web console Broswer tab - IBM CLoud Shell Note: To access the pre-provisioned IBM Cloud Kubernetes Cluster, select the correct account (1840867-Advowork) during login. Example: Select an account: 1 . Thomas S\u00fcdbr\u00f6cker ' s Account ( 641XXXXXXXXe ) <-> 123456 2 . Advowork ( e2bXXXXXXXX4 ) <-> 1840867 Enter a number> 2 Step 4. Create an environment variable $MYCLUSTER \u00b6 Enter the following command to display the name of your cluster, its ID, and a few other things. ibmcloud ks cluster ls Example output: Name ID State Created Workers Location Version Resource Group Name Provider mycluster-ams03-b3c.4x16 bsk19dhd0efh3hp3b05g normal 1 day ago 2 Dallas 1 .17.9_1534 default classic Create an environment variable $MYCLUSTER that contains the name of your cluster, e.g. export MYCLUSTER = your_pre_provisioned_clustername Congratulations, you have successfully completed this the setup. Awesome","title":"Access IBM Cloud Shell and get the code"},{"location":"pre-work/CLOUD_SHELL/#ibm-cloud-shell","text":"For this workshop we'll be using the IBM Cloud Shell as work environment. The IBM Cloud Shell is a cloud-based shell that you can access through your browser. It is preconfigured with the full IBM Cloud CLI and other 3 rd party CLIs like OpenShift's oc , Helm's helm , Kubernetes' kubectl , etc. You can find the list of installed plug-ins here .","title":"IBM Cloud Shell"},{"location":"pre-work/CLOUD_SHELL/#step-1-setup-the-ibm-cloud-shell-terminal-session","text":"When using the IBM Cloud Shell, no client side setup is required for this workshop, it comes with all necessary CLIs (command line tools). In your browser, login to the IBM Cloud Dashboard. Make sure you select your own account in the account list at the top, then click on the IBM Cloud Shell icon. This opens a new browser tab with your IBM Cloud Shell session. Note: Your workspace includes 500 MB of temporary storage. This session will close after an hour of inactivity. If you don't have any active sessions for an hour or you reach the 50-hour weekly usage limit, your workspace data is removed. You should see you personal ID as Current account: [User]'s Account' : If you want to perform this workshop locally on your own workstation, you need a local terminal and the following tools: git curl kubectl yarn mvn Node.js Java 9 or higher","title":"Step 1: Setup the IBM Cloud Shell terminal session"},{"location":"pre-work/CLOUD_SHELL/#step-2-get-the-code","text":"In the IBM Cloud Shell execute the following command: git clone https://github.com/IBM/cloud-native-starter.git cd cloud-native-starter/security ROOT_FOLDER = $( pwd ) echo $ROOT_FOLDER","title":"Step 2: Get the Code"},{"location":"pre-work/CLOUD_SHELL/#step-3-get-access-to-kubernetes","text":"Open provided Kubernetes cluster again in your browser tab, with the IBM Cloud web console. Switch from your own account to the provided IBM account . Switch back to the 1840867-IBM account by clicking on the account selection drop down in the top navigation bar. Click on your cluster. Now select Access on the left-hand side, here you see all steps to access your Kubernetes Cluster in a terminal session. You can easily copy and paste the given commands. Go back to the open browser tab the open Kubernetes Cluster in the IBM Cloud web console. Now select Actions->Connect via CLI on the right-hand side. Now copy and paste all these commands in sequence in your open IBM Cloud Shell terminal session. Browser tab - IBM Cloud web console Broswer tab - IBM CLoud Shell Note: To access the pre-provisioned IBM Cloud Kubernetes Cluster, select the correct account (1840867-Advowork) during login. Example: Select an account: 1 . Thomas S\u00fcdbr\u00f6cker ' s Account ( 641XXXXXXXXe ) <-> 123456 2 . Advowork ( e2bXXXXXXXX4 ) <-> 1840867 Enter a number> 2","title":"Step 3. Get Access to Kubernetes"},{"location":"pre-work/CLOUD_SHELL/#step-4-create-an-environment-variable-mycluster","text":"Enter the following command to display the name of your cluster, its ID, and a few other things. ibmcloud ks cluster ls Example output: Name ID State Created Workers Location Version Resource Group Name Provider mycluster-ams03-b3c.4x16 bsk19dhd0efh3hp3b05g normal 1 day ago 2 Dallas 1 .17.9_1534 default classic Create an environment variable $MYCLUSTER that contains the name of your cluster, e.g. export MYCLUSTER = your_pre_provisioned_clustername Congratulations, you have successfully completed this the setup. Awesome","title":"Step 4. Create an environment variable $MYCLUSTER"}]}